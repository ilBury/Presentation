{
  "_entries": [
    {
      "name": "mobx",
      "path": "C:\\projects\\presentation-app\\node_modules\\mobx\\dist\\mobx.esm.js",
      "lastModified": 1732022948602,
      "type": "module",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n  var global$1 = (typeof global !== \"undefined\" ? global :\n    typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window : {});\n\n  function die(error) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    throw new Error(typeof error === \"number\" ? \"[MobX] minified error nr: \" + error + (args.length ? \" \" + args.map(String).join(\",\") : \"\") + \". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts\" : \"[MobX] \" + error);\n  }\n  var mockGlobal = {};\n  function getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n      return globalThis;\n    }\n    if (typeof window !== \"undefined\") {\n      return window;\n    }\n    if (typeof global$1 !== \"undefined\") {\n      return global$1;\n    }\n    if (typeof self !== \"undefined\") {\n      return self;\n    }\n    return mockGlobal;\n  }\n  var assign = Object.assign;\n  var getDescriptor = Object.getOwnPropertyDescriptor;\n  var defineProperty = Object.defineProperty;\n  var objectPrototype = Object.prototype;\n  var EMPTY_ARRAY = [];\n  Object.freeze(EMPTY_ARRAY);\n  var EMPTY_OBJECT = {};\n  Object.freeze(EMPTY_OBJECT);\n  var hasProxy = typeof Proxy !== \"undefined\";\n  var plainObjectString = Object.toString();\n  function assertProxies() {\n    if (!hasProxy) {\n      die(\"Proxy not available\");\n    }\n  }\n  function once(func) {\n    var invoked = false;\n    return function () {\n      if (invoked) {\n        return;\n      }\n      invoked = true;\n      return func.apply(this, arguments);\n    };\n  }\n  var noop = function noop() {};\n  function isFunction(fn) {\n    return typeof fn === \"function\";\n  }\n  function isStringish(value) {\n    var t = typeof value;\n    switch (t) {\n      case \"string\":\n      case \"symbol\":\n      case \"number\":\n        return true;\n    }\n    return false;\n  }\n  function isObject(value) {\n    return value !== null && typeof value === \"object\";\n  }\n  function isPlainObject(value) {\n    if (!isObject(value)) {\n      return false;\n    }\n    var proto = Object.getPrototypeOf(value);\n    if (proto == null) {\n      return true;\n    }\n    var protoConstructor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n    return typeof protoConstructor === \"function\" && protoConstructor.toString() === plainObjectString;\n  }\n  function isGenerator(obj) {\n    var constructor = obj == null ? void 0 : obj.constructor;\n    if (!constructor) {\n      return false;\n    }\n    if (\"GeneratorFunction\" === constructor.name || \"GeneratorFunction\" === constructor.displayName) {\n      return true;\n    }\n    return false;\n  }\n  function addHiddenProp(object, propName, value) {\n    defineProperty(object, propName, {\n      enumerable: false,\n      writable: true,\n      configurable: true,\n      value: value\n    });\n  }\n  function addHiddenFinalProp(object, propName, value) {\n    defineProperty(object, propName, {\n      enumerable: false,\n      writable: false,\n      configurable: true,\n      value: value\n    });\n  }\n  function createInstanceofPredicate(name, theClass) {\n    var propName = \"isMobX\" + name;\n    theClass.prototype[propName] = true;\n    return function (x) {\n      return isObject(x) && x[propName] === true;\n    };\n  }\n  function isES6Map(thing) {\n    return thing != null && Object.prototype.toString.call(thing) === \"[object Map]\";\n  }\n  function isPlainES6Map(thing) {\n    var mapProto = Object.getPrototypeOf(thing);\n    var objectProto = Object.getPrototypeOf(mapProto);\n    var nullProto = Object.getPrototypeOf(objectProto);\n    return nullProto === null;\n  }\n  function isES6Set(thing) {\n    return thing != null && Object.prototype.toString.call(thing) === \"[object Set]\";\n  }\n  var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== \"undefined\";\n  function getPlainObjectKeys(object) {\n    var keys = Object.keys(object);\n    if (!hasGetOwnPropertySymbols) {\n      return keys;\n    }\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (!symbols.length) {\n      return keys;\n    }\n    return [].concat(keys, symbols.filter(function (s) {\n      return objectPrototype.propertyIsEnumerable.call(object, s);\n    }));\n  }\n  var ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function (obj) {\n    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n  } : Object.getOwnPropertyNames;\n  function toPrimitive(value) {\n    return value === null ? null : typeof value === \"object\" ? \"\" + value : value;\n  }\n  function hasProp(target, prop) {\n    return objectPrototype.hasOwnProperty.call(target, prop);\n  }\n  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || (function getOwnPropertyDescriptors(target) {\n    var res = {};\n    ownKeys(target).forEach(function (key) {\n      res[key] = getDescriptor(target, key);\n    });\n    return res;\n  });\n  function getFlag(flags, mask) {\n    return !!(flags & mask);\n  }\n  function setFlag(flags, mask, newValue) {\n    if (newValue) {\n      flags |= mask;\n    } else {\n      flags &= ~mask;\n    }\n    return flags;\n  }\n  function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n    return n;\n  }\n  function _defineProperties(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      (o.enumerable = o.enumerable || !1, o.configurable = !0, (\"value\" in o) && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o));\n    }\n  }\n  function _createClass(e, r, t) {\n    return (r && _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), e);\n  }\n  function _createForOfIteratorHelperLoose(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (t) return (t = t.call(r)).next.bind(t);\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n      t && (r = t);\n      var o = 0;\n      return function () {\n        return o >= r.length ? {\n          done: !0\n        } : {\n          done: !1,\n          value: r[o++]\n        };\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _extends() {\n    return (_extends = Object.assign ? Object.assign.bind() : function (n) {\n      for (var e = 1; e < arguments.length; e++) {\n        var t = arguments[e];\n        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n      }\n      return n;\n    }, _extends.apply(null, arguments));\n  }\n  function _inheritsLoose(t, o) {\n    (t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o));\n  }\n  function _setPrototypeOf(t, e) {\n    return (_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return (t.__proto__ = e, t);\n    }, _setPrototypeOf(t, e));\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r);\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (String )(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n  }\n  function _unsupportedIterableToArray(r, a) {\n    if (r) {\n      if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n      var t = ({}).toString.call(r).slice(8, -1);\n      return (\"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || (/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/).test(t) ? _arrayLikeToArray(r, a) : void 0);\n    }\n  }\n  var storedAnnotationsSymbol = Symbol(\"mobx-stored-annotations\");\n  function createDecoratorAnnotation(annotation) {\n    function decorator(target, property) {\n      if (is20223Decorator(property)) {\n        return annotation.decorate_20223_(target, property);\n      } else {\n        storeAnnotation(target, property, annotation);\n      }\n    }\n    return Object.assign(decorator, annotation);\n  }\n  function storeAnnotation(prototype, key, annotation) {\n    if (!hasProp(prototype, storedAnnotationsSymbol)) {\n      addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));\n    }\n    if (!isOverride(annotation)) {\n      prototype[storedAnnotationsSymbol][key] = annotation;\n    }\n  }\n  function collectStoredAnnotations(target) {\n    if (!hasProp(target, storedAnnotationsSymbol)) {\n      addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));\n    }\n    return target[storedAnnotationsSymbol];\n  }\n  function is20223Decorator(context) {\n    return typeof context == \"object\" && typeof context[\"kind\"] == \"string\";\n  }\n  var $mobx = Symbol(\"mobx administration\");\n  var Atom = (function () {\n    function Atom(name_) {\n      if (name_ === void 0) {\n        name_ = \"Atom\";\n      }\n      this.name_ = void 0;\n      this.flags_ = 0;\n      this.observers_ = new Set();\n      this.lastAccessedBy_ = 0;\n      this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;\n      this.onBOL = void 0;\n      this.onBUOL = void 0;\n      this.name_ = name_;\n    }\n    var _proto = Atom.prototype;\n    _proto.onBO = function onBO() {\n      if (this.onBOL) {\n        this.onBOL.forEach(function (listener) {\n          return listener();\n        });\n      }\n    };\n    _proto.onBUO = function onBUO() {\n      if (this.onBUOL) {\n        this.onBUOL.forEach(function (listener) {\n          return listener();\n        });\n      }\n    };\n    _proto.reportObserved = function reportObserved$1() {\n      return reportObserved(this);\n    };\n    _proto.reportChanged = function reportChanged() {\n      startBatch();\n      propagateChanged(this);\n      endBatch();\n    };\n    _proto.toString = function toString() {\n      return this.name_;\n    };\n    return _createClass(Atom, [{\n      key: \"isBeingObserved\",\n      get: function get() {\n        return getFlag(this.flags_, Atom.isBeingObservedMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, Atom.isBeingObservedMask_, newValue);\n      }\n    }, {\n      key: \"isPendingUnobservation\",\n      get: function get() {\n        return getFlag(this.flags_, Atom.isPendingUnobservationMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, Atom.isPendingUnobservationMask_, newValue);\n      }\n    }, {\n      key: \"diffValue\",\n      get: function get() {\n        return getFlag(this.flags_, Atom.diffValueMask_) ? 1 : 0;\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, Atom.diffValueMask_, newValue === 1 ? true : false);\n      }\n    }]);\n  })();\n  Atom.isBeingObservedMask_ = 1;\n  Atom.isPendingUnobservationMask_ = 2;\n  Atom.diffValueMask_ = 4;\n  var isAtom = createInstanceofPredicate(\"Atom\", Atom);\n  function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n    if (onBecomeObservedHandler === void 0) {\n      onBecomeObservedHandler = noop;\n    }\n    if (onBecomeUnobservedHandler === void 0) {\n      onBecomeUnobservedHandler = noop;\n    }\n    var atom = new Atom(name);\n    if (onBecomeObservedHandler !== noop) {\n      onBecomeObserved(atom, onBecomeObservedHandler);\n    }\n    if (onBecomeUnobservedHandler !== noop) {\n      onBecomeUnobserved(atom, onBecomeUnobservedHandler);\n    }\n    return atom;\n  }\n  function identityComparer(a, b) {\n    return a === b;\n  }\n  function structuralComparer(a, b) {\n    return deepEqual(a, b);\n  }\n  function shallowComparer(a, b) {\n    return deepEqual(a, b, 1);\n  }\n  function defaultComparer(a, b) {\n    if (Object.is) {\n      return Object.is(a, b);\n    }\n    return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;\n  }\n  var comparer = {\n    identity: identityComparer,\n    structural: structuralComparer,\n    \"default\": defaultComparer,\n    shallow: shallowComparer\n  };\n  function deepEnhancer(v, _, name) {\n    if (isObservable(v)) {\n      return v;\n    }\n    if (Array.isArray(v)) {\n      return observable.array(v, {\n        name: name\n      });\n    }\n    if (isPlainObject(v)) {\n      return observable.object(v, undefined, {\n        name: name\n      });\n    }\n    if (isES6Map(v)) {\n      return observable.map(v, {\n        name: name\n      });\n    }\n    if (isES6Set(v)) {\n      return observable.set(v, {\n        name: name\n      });\n    }\n    if (typeof v === \"function\" && !isAction(v) && !isFlow(v)) {\n      if (isGenerator(v)) {\n        return flow(v);\n      } else {\n        return autoAction(name, v);\n      }\n    }\n    return v;\n  }\n  function shallowEnhancer(v, _, name) {\n    if (v === undefined || v === null) {\n      return v;\n    }\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {\n      return v;\n    }\n    if (Array.isArray(v)) {\n      return observable.array(v, {\n        name: name,\n        deep: false\n      });\n    }\n    if (isPlainObject(v)) {\n      return observable.object(v, undefined, {\n        name: name,\n        deep: false\n      });\n    }\n    if (isES6Map(v)) {\n      return observable.map(v, {\n        name: name,\n        deep: false\n      });\n    }\n    if (isES6Set(v)) {\n      return observable.set(v, {\n        name: name,\n        deep: false\n      });\n    }\n  }\n  function referenceEnhancer(newValue) {\n    return newValue;\n  }\n  function refStructEnhancer(v, oldValue) {\n    if (deepEqual(v, oldValue)) {\n      return oldValue;\n    }\n    return v;\n  }\n  var OVERRIDE = \"override\";\n  var override = createDecoratorAnnotation({\n    annotationType_: OVERRIDE,\n    make_: make_,\n    extend_: extend_,\n    decorate_20223_: decorate_20223_\n  });\n  function isOverride(annotation) {\n    return annotation.annotationType_ === OVERRIDE;\n  }\n  function make_(adm, key) {\n    return 0;\n  }\n  function extend_(adm, key, descriptor, proxyTrap) {\n    die(\"'\" + this.annotationType_ + \"' can only be used with 'makeObservable'\");\n  }\n  function decorate_20223_(desc, context) {\n    console.warn(\"'\" + this.annotationType_ + \"' cannot be used with decorators - this is a no-op\");\n  }\n  function createActionAnnotation(name, options) {\n    return {\n      annotationType_: name,\n      options_: options,\n      make_: make_$1,\n      extend_: extend_$1,\n      decorate_20223_: decorate_20223_$1\n    };\n  }\n  function make_$1(adm, key, descriptor, source) {\n    var _this$options_;\n    if ((_this$options_ = this.options_) != null && _this$options_.bound) {\n      return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;\n    }\n    if (source === adm.target_) {\n      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;\n    }\n    if (isAction(descriptor.value)) {\n      return 1;\n    }\n    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);\n    defineProperty(source, key, actionDescriptor);\n    return 2;\n  }\n  function extend_$1(adm, key, descriptor, proxyTrap) {\n    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);\n    return adm.defineProperty_(key, actionDescriptor, proxyTrap);\n  }\n  function decorate_20223_$1(mthd, context) {\n    var kind = context.kind, name = context.name, addInitializer = context.addInitializer;\n    var ann = this;\n    var _createAction = function _createAction(m) {\n      var _ann$options_$name, _ann$options_, _ann$options_$autoAct, _ann$options_2;\n      return createAction((_ann$options_$name = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.name) != null ? _ann$options_$name : name.toString(), m, (_ann$options_$autoAct = (_ann$options_2 = ann.options_) == null ? void 0 : _ann$options_2.autoAction) != null ? _ann$options_$autoAct : false);\n    };\n    if (kind == \"field\") {\n      return function (initMthd) {\n        var _ann$options_3;\n        var mthd = initMthd;\n        if (!isAction(mthd)) {\n          mthd = _createAction(mthd);\n        }\n        if ((_ann$options_3 = ann.options_) != null && _ann$options_3.bound) {\n          mthd = mthd.bind(this);\n          mthd.isMobxAction = true;\n        }\n        return mthd;\n      };\n    }\n    if (kind == \"method\") {\n      var _this$options_2;\n      if (!isAction(mthd)) {\n        mthd = _createAction(mthd);\n      }\n      if ((_this$options_2 = this.options_) != null && _this$options_2.bound) {\n        addInitializer(function () {\n          var self = this;\n          var bound = self[name].bind(self);\n          bound.isMobxAction = true;\n          self[name] = bound;\n        });\n      }\n      return mthd;\n    }\n    die(\"Cannot apply '\" + ann.annotationType_ + \"' to '\" + String(name) + \"' (kind: \" + kind + \"):\" + (\"\\n'\" + ann.annotationType_ + \"' can only be used on properties with a function value.\"));\n  }\n  function assertActionDescriptor(adm, _ref, key, _ref2) {\n    _ref.annotationType_;\n    _ref2.value;\n  }\n  function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {\n    var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;\n    if (safeDescriptors === void 0) {\n      safeDescriptors = globalState.safeDescriptors;\n    }\n    assertActionDescriptor(adm, annotation, key, descriptor);\n    var value = descriptor.value;\n    if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {\n      var _adm$proxy_;\n      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n    }\n    return {\n      value: createAction((_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(), value, (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false, (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : undefined),\n      configurable: safeDescriptors ? adm.isPlainObject_ : true,\n      enumerable: false,\n      writable: safeDescriptors ? false : true\n    };\n  }\n  function createFlowAnnotation(name, options) {\n    return {\n      annotationType_: name,\n      options_: options,\n      make_: make_$2,\n      extend_: extend_$2,\n      decorate_20223_: decorate_20223_$2\n    };\n  }\n  function make_$2(adm, key, descriptor, source) {\n    var _this$options_;\n    if (source === adm.target_) {\n      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;\n    }\n    if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {\n      if (this.extend_(adm, key, descriptor, false) === null) {\n        return 0;\n      }\n    }\n    if (isFlow(descriptor.value)) {\n      return 1;\n    }\n    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);\n    defineProperty(source, key, flowDescriptor);\n    return 2;\n  }\n  function extend_$2(adm, key, descriptor, proxyTrap) {\n    var _this$options_2;\n    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);\n    return adm.defineProperty_(key, flowDescriptor, proxyTrap);\n  }\n  function decorate_20223_$2(mthd, context) {\n    var _this$options_3;\n    var name = context.name, addInitializer = context.addInitializer;\n    if (!isFlow(mthd)) {\n      mthd = flow(mthd);\n    }\n    if ((_this$options_3 = this.options_) != null && _this$options_3.bound) {\n      addInitializer(function () {\n        var self = this;\n        var bound = self[name].bind(self);\n        bound.isMobXFlow = true;\n        self[name] = bound;\n      });\n    }\n    return mthd;\n  }\n  function assertFlowDescriptor(adm, _ref, key, _ref2) {\n    _ref.annotationType_;\n    _ref2.value;\n  }\n  function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {\n    if (safeDescriptors === void 0) {\n      safeDescriptors = globalState.safeDescriptors;\n    }\n    assertFlowDescriptor(adm, annotation, key, descriptor);\n    var value = descriptor.value;\n    if (!isFlow(value)) {\n      value = flow(value);\n    }\n    if (bound) {\n      var _adm$proxy_;\n      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n      value.isMobXFlow = true;\n    }\n    return {\n      value: value,\n      configurable: safeDescriptors ? adm.isPlainObject_ : true,\n      enumerable: false,\n      writable: safeDescriptors ? false : true\n    };\n  }\n  function createComputedAnnotation(name, options) {\n    return {\n      annotationType_: name,\n      options_: options,\n      make_: make_$3,\n      extend_: extend_$3,\n      decorate_20223_: decorate_20223_$3\n    };\n  }\n  function make_$3(adm, key, descriptor) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;\n  }\n  function extend_$3(adm, key, descriptor, proxyTrap) {\n    assertComputedDescriptor(adm, this, key, descriptor);\n    return adm.defineComputedProperty_(key, _extends({}, this.options_, {\n      get: descriptor.get,\n      set: descriptor.set\n    }), proxyTrap);\n  }\n  function decorate_20223_$3(get, context) {\n    var ann = this;\n    var key = context.name, addInitializer = context.addInitializer;\n    addInitializer(function () {\n      var adm = asObservableObject(this)[$mobx];\n      var options = _extends({}, ann.options_, {\n        get: get,\n        context: this\n      });\n      options.name || (options.name = \"ObservableObject.\" + key.toString());\n      adm.values_.set(key, new ComputedValue(options));\n    });\n    return function () {\n      return this[$mobx].getObservablePropValue_(key);\n    };\n  }\n  function assertComputedDescriptor(adm, _ref, key, _ref2) {\n    _ref.annotationType_;\n    _ref2.get;\n  }\n  function createObservableAnnotation(name, options) {\n    return {\n      annotationType_: name,\n      options_: options,\n      make_: make_$4,\n      extend_: extend_$4,\n      decorate_20223_: decorate_20223_$4\n    };\n  }\n  function make_$4(adm, key, descriptor) {\n    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;\n  }\n  function extend_$4(adm, key, descriptor, proxyTrap) {\n    var _this$options_$enhanc, _this$options_;\n    assertObservableDescriptor(adm, this);\n    return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);\n  }\n  function decorate_20223_$4(desc, context) {\n    var ann = this;\n    var kind = context.kind, name = context.name;\n    var initializedObjects = new WeakSet();\n    function initializeObservable(target, value) {\n      var _ann$options_$enhance, _ann$options_;\n      var adm = asObservableObject(target)[$mobx];\n      var observable = new ObservableValue(value, (_ann$options_$enhance = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.enhancer) != null ? _ann$options_$enhance : deepEnhancer, \"ObservableObject.\" + name.toString(), false);\n      adm.values_.set(name, observable);\n      initializedObjects.add(target);\n    }\n    if (kind == \"accessor\") {\n      return {\n        get: function get() {\n          if (!initializedObjects.has(this)) {\n            initializeObservable(this, desc.get.call(this));\n          }\n          return this[$mobx].getObservablePropValue_(name);\n        },\n        set: function set(value) {\n          if (!initializedObjects.has(this)) {\n            initializeObservable(this, value);\n          }\n          return this[$mobx].setObservablePropValue_(name, value);\n        },\n        init: function init(value) {\n          if (!initializedObjects.has(this)) {\n            initializeObservable(this, value);\n          }\n          return value;\n        }\n      };\n    }\n    return;\n  }\n  function assertObservableDescriptor(adm, _ref, key, descriptor) {\n    _ref.annotationType_;\n  }\n  var AUTO = \"true\";\n  var autoAnnotation = createAutoAnnotation();\n  function createAutoAnnotation(options) {\n    return {\n      annotationType_: AUTO,\n      options_: options,\n      make_: make_$5,\n      extend_: extend_$5,\n      decorate_20223_: decorate_20223_$5\n    };\n  }\n  function make_$5(adm, key, descriptor, source) {\n    var _this$options_3, _this$options_4;\n    if (descriptor.get) {\n      return computed.make_(adm, key, descriptor, source);\n    }\n    if (descriptor.set) {\n      var set = createAction(key.toString(), descriptor.set);\n      if (source === adm.target_) {\n        return adm.defineProperty_(key, {\n          configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n          set: set\n        }) === null ? 0 : 2;\n      }\n      defineProperty(source, key, {\n        configurable: true,\n        set: set\n      });\n      return 2;\n    }\n    if (source !== adm.target_ && typeof descriptor.value === \"function\") {\n      var _this$options_2;\n      if (isGenerator(descriptor.value)) {\n        var _this$options_;\n        var flowAnnotation = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;\n        return flowAnnotation.make_(adm, key, descriptor, source);\n      }\n      var actionAnnotation = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;\n      return actionAnnotation.make_(adm, key, descriptor, source);\n    }\n    var observableAnnotation = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;\n    if (typeof descriptor.value === \"function\" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {\n      var _adm$proxy_;\n      descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);\n    }\n    return observableAnnotation.make_(adm, key, descriptor, source);\n  }\n  function extend_$5(adm, key, descriptor, proxyTrap) {\n    var _this$options_5, _this$options_6;\n    if (descriptor.get) {\n      return computed.extend_(adm, key, descriptor, proxyTrap);\n    }\n    if (descriptor.set) {\n      return adm.defineProperty_(key, {\n        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,\n        set: createAction(key.toString(), descriptor.set)\n      }, proxyTrap);\n    }\n    if (typeof descriptor.value === \"function\" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {\n      var _adm$proxy_2;\n      descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);\n    }\n    var observableAnnotation = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;\n    return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);\n  }\n  function decorate_20223_$5(desc, context) {\n    die(\"'\" + this.annotationType_ + \"' cannot be used as a decorator\");\n  }\n  var OBSERVABLE = \"observable\";\n  var OBSERVABLE_REF = \"observable.ref\";\n  var OBSERVABLE_SHALLOW = \"observable.shallow\";\n  var OBSERVABLE_STRUCT = \"observable.struct\";\n  var defaultCreateObservableOptions = {\n    deep: true,\n    name: undefined,\n    defaultDecorator: undefined,\n    proxy: true\n  };\n  Object.freeze(defaultCreateObservableOptions);\n  function asCreateObservableOptions(thing) {\n    return thing || defaultCreateObservableOptions;\n  }\n  var observableAnnotation = createObservableAnnotation(OBSERVABLE);\n  var observableRefAnnotation = createObservableAnnotation(OBSERVABLE_REF, {\n    enhancer: referenceEnhancer\n  });\n  var observableShallowAnnotation = createObservableAnnotation(OBSERVABLE_SHALLOW, {\n    enhancer: shallowEnhancer\n  });\n  var observableStructAnnotation = createObservableAnnotation(OBSERVABLE_STRUCT, {\n    enhancer: refStructEnhancer\n  });\n  var observableDecoratorAnnotation = createDecoratorAnnotation(observableAnnotation);\n  function getEnhancerFromOptions(options) {\n    return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);\n  }\n  function getAnnotationFromOptions(options) {\n    var _options$defaultDecor;\n    return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : undefined;\n  }\n  function getEnhancerFromAnnotation(annotation) {\n    var _annotation$options_$, _annotation$options_;\n    return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;\n  }\n  function createObservable(v, arg2, arg3) {\n    if (is20223Decorator(arg2)) {\n      return observableAnnotation.decorate_20223_(v, arg2);\n    }\n    if (isStringish(arg2)) {\n      storeAnnotation(v, arg2, observableAnnotation);\n      return;\n    }\n    if (isObservable(v)) {\n      return v;\n    }\n    if (isPlainObject(v)) {\n      return observable.object(v, arg2, arg3);\n    }\n    if (Array.isArray(v)) {\n      return observable.array(v, arg2);\n    }\n    if (isES6Map(v)) {\n      return observable.map(v, arg2);\n    }\n    if (isES6Set(v)) {\n      return observable.set(v, arg2);\n    }\n    if (typeof v === \"object\" && v !== null) {\n      return v;\n    }\n    return observable.box(v, arg2);\n  }\n  assign(createObservable, observableDecoratorAnnotation);\n  var observableFactories = {\n    box: function box(value, options) {\n      var o = asCreateObservableOptions(options);\n      return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);\n    },\n    array: function array(initialValues, options) {\n      var o = asCreateObservableOptions(options);\n      return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    map: function map(initialValues, options) {\n      var o = asCreateObservableOptions(options);\n      return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    set: function set(initialValues, options) {\n      var o = asCreateObservableOptions(options);\n      return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);\n    },\n    object: function object(props, decorators, options) {\n      return initObservable(function () {\n        return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);\n      });\n    },\n    ref: createDecoratorAnnotation(observableRefAnnotation),\n    shallow: createDecoratorAnnotation(observableShallowAnnotation),\n    deep: observableDecoratorAnnotation,\n    struct: createDecoratorAnnotation(observableStructAnnotation)\n  };\n  var observable = assign(createObservable, observableFactories);\n  var COMPUTED = \"computed\";\n  var COMPUTED_STRUCT = \"computed.struct\";\n  var computedAnnotation = createComputedAnnotation(COMPUTED);\n  var computedStructAnnotation = createComputedAnnotation(COMPUTED_STRUCT, {\n    equals: comparer.structural\n  });\n  var computed = function computed(arg1, arg2) {\n    if (is20223Decorator(arg2)) {\n      return computedAnnotation.decorate_20223_(arg1, arg2);\n    }\n    if (isStringish(arg2)) {\n      return storeAnnotation(arg1, arg2, computedAnnotation);\n    }\n    if (isPlainObject(arg1)) {\n      return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));\n    }\n    var opts = isPlainObject(arg2) ? arg2 : {};\n    opts.get = arg1;\n    opts.name || (opts.name = arg1.name || \"\");\n    return new ComputedValue(opts);\n  };\n  Object.assign(computed, computedAnnotation);\n  computed.struct = createDecoratorAnnotation(computedStructAnnotation);\n  var _getDescriptor$config, _getDescriptor;\n  var currentActionId = 0;\n  var nextActionId = 1;\n  var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = getDescriptor(function () {}, \"name\")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;\n  var tmpNameDescriptor = {\n    value: \"action\",\n    configurable: true,\n    writable: false,\n    enumerable: false\n  };\n  function createAction(actionName, fn, autoAction, ref) {\n    if (autoAction === void 0) {\n      autoAction = false;\n    }\n    function res() {\n      return executeAction(actionName, autoAction, fn, ref || this, arguments);\n    }\n    res.isMobxAction = true;\n    res.toString = function () {\n      return fn.toString();\n    };\n    if (isFunctionNameConfigurable) {\n      tmpNameDescriptor.value = actionName;\n      defineProperty(res, \"name\", tmpNameDescriptor);\n    }\n    return res;\n  }\n  function executeAction(actionName, canRunAsDerivation, fn, scope, args) {\n    var runInfo = _startAction(actionName, canRunAsDerivation);\n    try {\n      return fn.apply(scope, args);\n    } catch (err) {\n      runInfo.error_ = err;\n      throw err;\n    } finally {\n      _endAction(runInfo);\n    }\n  }\n  function _startAction(actionName, canRunAsDerivation, scope, args) {\n    var notifySpy_ = \"production\" !== \"production\";\n    var startTime_ = 0;\n    var prevDerivation_ = globalState.trackingDerivation;\n    var runAsAction = !canRunAsDerivation || !prevDerivation_;\n    startBatch();\n    var prevAllowStateChanges_ = globalState.allowStateChanges;\n    if (runAsAction) {\n      untrackedStart();\n      prevAllowStateChanges_ = allowStateChangesStart(true);\n    }\n    var prevAllowStateReads_ = allowStateReadsStart(true);\n    var runInfo = {\n      runAsAction_: runAsAction,\n      prevDerivation_: prevDerivation_,\n      prevAllowStateChanges_: prevAllowStateChanges_,\n      prevAllowStateReads_: prevAllowStateReads_,\n      notifySpy_: notifySpy_,\n      startTime_: startTime_,\n      actionId_: nextActionId++,\n      parentActionId_: currentActionId\n    };\n    currentActionId = runInfo.actionId_;\n    return runInfo;\n  }\n  function _endAction(runInfo) {\n    if (currentActionId !== runInfo.actionId_) {\n      die(30);\n    }\n    currentActionId = runInfo.parentActionId_;\n    if (runInfo.error_ !== undefined) {\n      globalState.suppressReactionErrors = true;\n    }\n    allowStateChangesEnd(runInfo.prevAllowStateChanges_);\n    allowStateReadsEnd(runInfo.prevAllowStateReads_);\n    endBatch();\n    if (runInfo.runAsAction_) {\n      untrackedEnd(runInfo.prevDerivation_);\n    }\n    globalState.suppressReactionErrors = false;\n  }\n  function allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    try {\n      return func();\n    } finally {\n      allowStateChangesEnd(prev);\n    }\n  }\n  function allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n  }\n  function allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n  }\n  var ObservableValue = (function (_Atom) {\n    function ObservableValue(value, enhancer, name_, notifySpy, equals) {\n      var _this;\n      if (name_ === void 0) {\n        name_ = \"ObservableValue\";\n      }\n      if (equals === void 0) {\n        equals = comparer[\"default\"];\n      }\n      _this = _Atom.call(this, name_) || this;\n      _this.enhancer = void 0;\n      _this.name_ = void 0;\n      _this.equals = void 0;\n      _this.hasUnreportedChange_ = false;\n      _this.interceptors_ = void 0;\n      _this.changeListeners_ = void 0;\n      _this.value_ = void 0;\n      _this.dehancer = void 0;\n      _this.enhancer = enhancer;\n      _this.name_ = name_;\n      _this.equals = equals;\n      _this.value_ = enhancer(value, undefined, name_);\n      return _this;\n    }\n    _inheritsLoose(ObservableValue, _Atom);\n    var _proto = ObservableValue.prototype;\n    _proto.dehanceValue = function dehanceValue(value) {\n      if (this.dehancer !== undefined) {\n        return this.dehancer(value);\n      }\n      return value;\n    };\n    _proto.set = function set(newValue) {\n      this.value_;\n      newValue = this.prepareNewValue_(newValue);\n      if (newValue !== globalState.UNCHANGED) {\n        this.setNewValue_(newValue);\n      }\n    };\n    _proto.prepareNewValue_ = function prepareNewValue_(newValue) {\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          object: this,\n          type: UPDATE,\n          newValue: newValue\n        });\n        if (!change) {\n          return globalState.UNCHANGED;\n        }\n        newValue = change.newValue;\n      }\n      newValue = this.enhancer(newValue, this.value_, this.name_);\n      return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;\n    };\n    _proto.setNewValue_ = function setNewValue_(newValue) {\n      var oldValue = this.value_;\n      this.value_ = newValue;\n      this.reportChanged();\n      if (hasListeners(this)) {\n        notifyListeners(this, {\n          type: UPDATE,\n          object: this,\n          newValue: newValue,\n          oldValue: oldValue\n        });\n      }\n    };\n    _proto.get = function get() {\n      this.reportObserved();\n      return this.dehanceValue(this.value_);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n      return registerInterceptor(this, handler);\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n      if (fireImmediately) {\n        listener({\n          observableKind: \"value\",\n          debugObjectName: this.name_,\n          object: this,\n          type: UPDATE,\n          newValue: this.value_,\n          oldValue: undefined\n        });\n      }\n      return registerListener(this, listener);\n    };\n    _proto.raw = function raw() {\n      return this.value_;\n    };\n    _proto.toJSON = function toJSON() {\n      return this.get();\n    };\n    _proto.toString = function toString() {\n      return this.name_ + \"[\" + this.value_ + \"]\";\n    };\n    _proto.valueOf = function valueOf() {\n      return toPrimitive(this.get());\n    };\n    _proto[Symbol.toPrimitive] = function () {\n      return this.valueOf();\n    };\n    return ObservableValue;\n  })(Atom);\n  var isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\n  var ComputedValue = (function () {\n    function ComputedValue(options) {\n      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n      this.observing_ = [];\n      this.newObserving_ = null;\n      this.observers_ = new Set();\n      this.runId_ = 0;\n      this.lastAccessedBy_ = 0;\n      this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n      this.unboundDepsCount_ = 0;\n      this.value_ = new CaughtException(null);\n      this.name_ = void 0;\n      this.triggeredBy_ = void 0;\n      this.flags_ = 0;\n      this.derivation = void 0;\n      this.setter_ = void 0;\n      this.isTracing_ = TraceMode.NONE;\n      this.scope_ = void 0;\n      this.equals_ = void 0;\n      this.requiresReaction_ = void 0;\n      this.keepAlive_ = void 0;\n      this.onBOL = void 0;\n      this.onBUOL = void 0;\n      if (!options.get) {\n        die(31);\n      }\n      this.derivation = options.get;\n      this.name_ = options.name || (\"ComputedValue\");\n      if (options.set) {\n        this.setter_ = createAction(\"ComputedValue-setter\", options.set);\n      }\n      this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer[\"default\"]);\n      this.scope_ = options.context;\n      this.requiresReaction_ = options.requiresReaction;\n      this.keepAlive_ = !!options.keepAlive;\n    }\n    var _proto = ComputedValue.prototype;\n    _proto.onBecomeStale_ = function onBecomeStale_() {\n      propagateMaybeChanged(this);\n    };\n    _proto.onBO = function onBO() {\n      if (this.onBOL) {\n        this.onBOL.forEach(function (listener) {\n          return listener();\n        });\n      }\n    };\n    _proto.onBUO = function onBUO() {\n      if (this.onBUOL) {\n        this.onBUOL.forEach(function (listener) {\n          return listener();\n        });\n      }\n    };\n    _proto.get = function get() {\n      if (this.isComputing) {\n        die(32, this.name_, this.derivation);\n      }\n      if (globalState.inBatch === 0 && this.observers_.size === 0 && !this.keepAlive_) {\n        if (shouldCompute(this)) {\n          this.warnAboutUntrackedRead_();\n          startBatch();\n          this.value_ = this.computeValue_(false);\n          endBatch();\n        }\n      } else {\n        reportObserved(this);\n        if (shouldCompute(this)) {\n          var prevTrackingContext = globalState.trackingContext;\n          if (this.keepAlive_ && !prevTrackingContext) {\n            globalState.trackingContext = this;\n          }\n          if (this.trackAndCompute()) {\n            propagateChangeConfirmed(this);\n          }\n          globalState.trackingContext = prevTrackingContext;\n        }\n      }\n      var result = this.value_;\n      if (isCaughtException(result)) {\n        throw result.cause;\n      }\n      return result;\n    };\n    _proto.set = function set(value) {\n      if (this.setter_) {\n        if (this.isRunningSetter) {\n          die(33, this.name_);\n        }\n        this.isRunningSetter = true;\n        try {\n          this.setter_.call(this.scope_, value);\n        } finally {\n          this.isRunningSetter = false;\n        }\n      } else {\n        die(34, this.name_);\n      }\n    };\n    _proto.trackAndCompute = function trackAndCompute() {\n      var oldValue = this.value_;\n      var wasSuspended = this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;\n      var newValue = this.computeValue_(true);\n      var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);\n      if (changed) {\n        this.value_ = newValue;\n      }\n      return changed;\n    };\n    _proto.computeValue_ = function computeValue_(track) {\n      this.isComputing = true;\n      var prev = allowStateChangesStart(false);\n      var res;\n      if (track) {\n        res = trackDerivedFunction(this, this.derivation, this.scope_);\n      } else {\n        if (globalState.disableErrorBoundaries === true) {\n          res = this.derivation.call(this.scope_);\n        } else {\n          try {\n            res = this.derivation.call(this.scope_);\n          } catch (e) {\n            res = new CaughtException(e);\n          }\n        }\n      }\n      allowStateChangesEnd(prev);\n      this.isComputing = false;\n      return res;\n    };\n    _proto.suspend_ = function suspend_() {\n      if (!this.keepAlive_) {\n        clearObserving(this);\n        this.value_ = undefined;\n      }\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n      var _this = this;\n      var firstTime = true;\n      var prevValue = undefined;\n      return autorun(function () {\n        var newValue = _this.get();\n        if (!firstTime || fireImmediately) {\n          var prevU = untrackedStart();\n          listener({\n            observableKind: \"computed\",\n            debugObjectName: _this.name_,\n            type: UPDATE,\n            object: _this,\n            newValue: newValue,\n            oldValue: prevValue\n          });\n          untrackedEnd(prevU);\n        }\n        firstTime = false;\n        prevValue = newValue;\n      });\n    };\n    _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {\n      {\n        return;\n      }\n    };\n    _proto.toString = function toString() {\n      return this.name_ + \"[\" + this.derivation.toString() + \"]\";\n    };\n    _proto.valueOf = function valueOf() {\n      return toPrimitive(this.get());\n    };\n    _proto[Symbol.toPrimitive] = function () {\n      return this.valueOf();\n    };\n    return _createClass(ComputedValue, [{\n      key: \"isComputing\",\n      get: function get() {\n        return getFlag(this.flags_, ComputedValue.isComputingMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, ComputedValue.isComputingMask_, newValue);\n      }\n    }, {\n      key: \"isRunningSetter\",\n      get: function get() {\n        return getFlag(this.flags_, ComputedValue.isRunningSetterMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, ComputedValue.isRunningSetterMask_, newValue);\n      }\n    }, {\n      key: \"isBeingObserved\",\n      get: function get() {\n        return getFlag(this.flags_, ComputedValue.isBeingObservedMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, ComputedValue.isBeingObservedMask_, newValue);\n      }\n    }, {\n      key: \"isPendingUnobservation\",\n      get: function get() {\n        return getFlag(this.flags_, ComputedValue.isPendingUnobservationMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, ComputedValue.isPendingUnobservationMask_, newValue);\n      }\n    }, {\n      key: \"diffValue\",\n      get: function get() {\n        return getFlag(this.flags_, ComputedValue.diffValueMask_) ? 1 : 0;\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, ComputedValue.diffValueMask_, newValue === 1 ? true : false);\n      }\n    }]);\n  })();\n  ComputedValue.isComputingMask_ = 1;\n  ComputedValue.isRunningSetterMask_ = 2;\n  ComputedValue.isBeingObservedMask_ = 4;\n  ComputedValue.isPendingUnobservationMask_ = 8;\n  ComputedValue.diffValueMask_ = 16;\n  var isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\n  var IDerivationState_;\n  (function (IDerivationState_) {\n    IDerivationState_[IDerivationState_[\"NOT_TRACKING_\"] = -1] = \"NOT_TRACKING_\";\n    IDerivationState_[IDerivationState_[\"UP_TO_DATE_\"] = 0] = \"UP_TO_DATE_\";\n    IDerivationState_[IDerivationState_[\"POSSIBLY_STALE_\"] = 1] = \"POSSIBLY_STALE_\";\n    IDerivationState_[IDerivationState_[\"STALE_\"] = 2] = \"STALE_\";\n  })(IDerivationState_ || (IDerivationState_ = {}));\n  var TraceMode;\n  (function (TraceMode) {\n    TraceMode[TraceMode[\"NONE\"] = 0] = \"NONE\";\n    TraceMode[TraceMode[\"LOG\"] = 1] = \"LOG\";\n    TraceMode[TraceMode[\"BREAK\"] = 2] = \"BREAK\";\n  })(TraceMode || (TraceMode = {}));\n  var CaughtException = function CaughtException(cause) {\n    this.cause = void 0;\n    this.cause = cause;\n  };\n  function isCaughtException(e) {\n    return e instanceof CaughtException;\n  }\n  function shouldCompute(derivation) {\n    switch (derivation.dependenciesState_) {\n      case IDerivationState_.UP_TO_DATE_:\n        return false;\n      case IDerivationState_.NOT_TRACKING_:\n      case IDerivationState_.STALE_:\n        return true;\n      case IDerivationState_.POSSIBLY_STALE_:\n        {\n          var prevAllowStateReads = allowStateReadsStart(true);\n          var prevUntracked = untrackedStart();\n          var obs = derivation.observing_, l = obs.length;\n          for (var i = 0; i < l; i++) {\n            var obj = obs[i];\n            if (isComputedValue(obj)) {\n              if (globalState.disableErrorBoundaries) {\n                obj.get();\n              } else {\n                try {\n                  obj.get();\n                } catch (e) {\n                  untrackedEnd(prevUntracked);\n                  allowStateReadsEnd(prevAllowStateReads);\n                  return true;\n                }\n              }\n              if (derivation.dependenciesState_ === IDerivationState_.STALE_) {\n                untrackedEnd(prevUntracked);\n                allowStateReadsEnd(prevAllowStateReads);\n                return true;\n              }\n            }\n          }\n          changeDependenciesStateTo0(derivation);\n          untrackedEnd(prevUntracked);\n          allowStateReadsEnd(prevAllowStateReads);\n          return false;\n        }\n    }\n  }\n  function isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n  }\n  function checkIfStateModificationsAreAllowed(atom) {\n    {\n      return;\n    }\n  }\n  function trackDerivedFunction(derivation, f, context) {\n    var prevAllowStateReads = allowStateReadsStart(true);\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving_ = new Array(derivation.runId_ === 0 ? 100 : derivation.observing_.length);\n    derivation.unboundDepsCount_ = 0;\n    derivation.runId_ = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    globalState.inBatch++;\n    var result;\n    if (globalState.disableErrorBoundaries === true) {\n      result = f.call(context);\n    } else {\n      try {\n        result = f.call(context);\n      } catch (e) {\n        result = new CaughtException(e);\n      }\n    }\n    globalState.inBatch--;\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    allowStateReadsEnd(prevAllowStateReads);\n    return result;\n  }\n  function bindDependencies(derivation) {\n    var prevObserving = derivation.observing_;\n    var observing = derivation.observing_ = derivation.newObserving_;\n    var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;\n    var i0 = 0, l = derivation.unboundDepsCount_;\n    for (var i = 0; i < l; i++) {\n      var dep = observing[i];\n      if (dep.diffValue === 0) {\n        dep.diffValue = 1;\n        if (i0 !== i) {\n          observing[i0] = dep;\n        }\n        i0++;\n      }\n      if (dep.dependenciesState_ > lowestNewObservingDerivationState) {\n        lowestNewObservingDerivationState = dep.dependenciesState_;\n      }\n    }\n    observing.length = i0;\n    derivation.newObserving_ = null;\n    l = prevObserving.length;\n    while (l--) {\n      var _dep = prevObserving[l];\n      if (_dep.diffValue === 0) {\n        removeObserver(_dep, derivation);\n      }\n      _dep.diffValue = 0;\n    }\n    while (i0--) {\n      var _dep2 = observing[i0];\n      if (_dep2.diffValue === 1) {\n        _dep2.diffValue = 0;\n        addObserver(_dep2, derivation);\n      }\n    }\n    if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {\n      derivation.dependenciesState_ = lowestNewObservingDerivationState;\n      derivation.onBecomeStale_();\n    }\n  }\n  function clearObserving(derivation) {\n    var obs = derivation.observing_;\n    derivation.observing_ = [];\n    var i = obs.length;\n    while (i--) {\n      removeObserver(obs[i], derivation);\n    }\n    derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n  }\n  function untracked(action) {\n    var prev = untrackedStart();\n    try {\n      return action();\n    } finally {\n      untrackedEnd(prev);\n    }\n  }\n  function untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n  }\n  function untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n  }\n  function allowStateReadsStart(allowStateReads) {\n    var prev = globalState.allowStateReads;\n    globalState.allowStateReads = allowStateReads;\n    return prev;\n  }\n  function allowStateReadsEnd(prev) {\n    globalState.allowStateReads = prev;\n  }\n  function changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n      return;\n    }\n    derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;\n    var obs = derivation.observing_;\n    var i = obs.length;\n    while (i--) {\n      obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n    }\n  }\n  var persistentKeys = [\"mobxGuid\", \"spyListeners\", \"enforceActions\", \"computedRequiresReaction\", \"reactionRequiresObservable\", \"observableRequiresReaction\", \"allowStateReads\", \"disableErrorBoundaries\", \"runId\", \"UNCHANGED\", \"useProxies\"];\n  var MobXGlobals = function MobXGlobals() {\n    this.version = 6;\n    this.UNCHANGED = {};\n    this.trackingDerivation = null;\n    this.trackingContext = null;\n    this.runId = 0;\n    this.mobxGuid = 0;\n    this.inBatch = 0;\n    this.pendingUnobservations = [];\n    this.pendingReactions = [];\n    this.isRunningReactions = false;\n    this.allowStateChanges = false;\n    this.allowStateReads = true;\n    this.enforceActions = true;\n    this.spyListeners = [];\n    this.globalReactionErrorHandlers = [];\n    this.computedRequiresReaction = false;\n    this.reactionRequiresObservable = false;\n    this.observableRequiresReaction = false;\n    this.disableErrorBoundaries = false;\n    this.suppressReactionErrors = false;\n    this.useProxies = true;\n    this.verifyProxies = false;\n    this.safeDescriptors = true;\n  };\n  var canMergeGlobalState = true;\n  var isolateCalled = false;\n  var globalState = (function () {\n    var global = getGlobal();\n    if (global.__mobxInstanceCount > 0 && !global.__mobxGlobals) {\n      canMergeGlobalState = false;\n    }\n    if (global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version) {\n      canMergeGlobalState = false;\n    }\n    if (!canMergeGlobalState) {\n      setTimeout(function () {\n        if (!isolateCalled) {\n          die(35);\n        }\n      }, 1);\n      return new MobXGlobals();\n    } else if (global.__mobxGlobals) {\n      global.__mobxInstanceCount += 1;\n      if (!global.__mobxGlobals.UNCHANGED) {\n        global.__mobxGlobals.UNCHANGED = {};\n      }\n      return global.__mobxGlobals;\n    } else {\n      global.__mobxInstanceCount = 1;\n      return global.__mobxGlobals = new MobXGlobals();\n    }\n  })();\n  function isolateGlobalState() {\n    if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {\n      die(36);\n    }\n    isolateCalled = true;\n    if (canMergeGlobalState) {\n      var global = getGlobal();\n      if (--global.__mobxInstanceCount === 0) {\n        global.__mobxGlobals = undefined;\n      }\n      globalState = new MobXGlobals();\n    }\n  }\n  function getGlobalState() {\n    return globalState;\n  }\n  function resetGlobalState() {\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n      if (persistentKeys.indexOf(key) === -1) {\n        globalState[key] = defaultGlobals[key];\n      }\n    }\n    globalState.allowStateChanges = !globalState.enforceActions;\n  }\n  function hasObservers(observable) {\n    return observable.observers_ && observable.observers_.size > 0;\n  }\n  function getObservers(observable) {\n    return observable.observers_;\n  }\n  function addObserver(observable, node) {\n    observable.observers_.add(node);\n    if (observable.lowestObserverState_ > node.dependenciesState_) {\n      observable.lowestObserverState_ = node.dependenciesState_;\n    }\n  }\n  function removeObserver(observable, node) {\n    observable.observers_[\"delete\"](node);\n    if (observable.observers_.size === 0) {\n      queueForUnobservation(observable);\n    }\n  }\n  function queueForUnobservation(observable) {\n    if (observable.isPendingUnobservation === false) {\n      observable.isPendingUnobservation = true;\n      globalState.pendingUnobservations.push(observable);\n    }\n  }\n  function startBatch() {\n    globalState.inBatch++;\n  }\n  function endBatch() {\n    if (--globalState.inBatch === 0) {\n      runReactions();\n      var list = globalState.pendingUnobservations;\n      for (var i = 0; i < list.length; i++) {\n        var observable = list[i];\n        observable.isPendingUnobservation = false;\n        if (observable.observers_.size === 0) {\n          if (observable.isBeingObserved) {\n            observable.isBeingObserved = false;\n            observable.onBUO();\n          }\n          if (observable instanceof ComputedValue) {\n            observable.suspend_();\n          }\n        }\n      }\n      globalState.pendingUnobservations = [];\n    }\n  }\n  function reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n      if (derivation.runId_ !== observable.lastAccessedBy_) {\n        observable.lastAccessedBy_ = derivation.runId_;\n        derivation.newObserving_[derivation.unboundDepsCount_++] = observable;\n        if (!observable.isBeingObserved && globalState.trackingContext) {\n          observable.isBeingObserved = true;\n          observable.onBO();\n        }\n      }\n      return observable.isBeingObserved;\n    } else if (observable.observers_.size === 0 && globalState.inBatch > 0) {\n      queueForUnobservation(observable);\n    }\n    return false;\n  }\n  function propagateChanged(observable) {\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n      return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\n    observable.observers_.forEach(function (d) {\n      if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n        d.onBecomeStale_();\n      }\n      d.dependenciesState_ = IDerivationState_.STALE_;\n    });\n  }\n  function propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState_ === IDerivationState_.STALE_) {\n      return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.STALE_;\n    observable.observers_.forEach(function (d) {\n      if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {\n        d.dependenciesState_ = IDerivationState_.STALE_;\n      } else if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n        observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;\n      }\n    });\n  }\n  function propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {\n      return;\n    }\n    observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;\n    observable.observers_.forEach(function (d) {\n      if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {\n        d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;\n        d.onBecomeStale_();\n      }\n    });\n  }\n  var Reaction = (function () {\n    function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {\n      if (name_ === void 0) {\n        name_ = \"Reaction\";\n      }\n      this.name_ = void 0;\n      this.onInvalidate_ = void 0;\n      this.errorHandler_ = void 0;\n      this.requiresObservable_ = void 0;\n      this.observing_ = [];\n      this.newObserving_ = [];\n      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;\n      this.runId_ = 0;\n      this.unboundDepsCount_ = 0;\n      this.flags_ = 0;\n      this.isTracing_ = TraceMode.NONE;\n      this.name_ = name_;\n      this.onInvalidate_ = onInvalidate_;\n      this.errorHandler_ = errorHandler_;\n      this.requiresObservable_ = requiresObservable_;\n    }\n    var _proto = Reaction.prototype;\n    _proto.onBecomeStale_ = function onBecomeStale_() {\n      this.schedule_();\n    };\n    _proto.schedule_ = function schedule_() {\n      if (!this.isScheduled) {\n        this.isScheduled = true;\n        globalState.pendingReactions.push(this);\n        runReactions();\n      }\n    };\n    _proto.runReaction_ = function runReaction_() {\n      if (!this.isDisposed) {\n        startBatch();\n        this.isScheduled = false;\n        var prev = globalState.trackingContext;\n        globalState.trackingContext = this;\n        if (shouldCompute(this)) {\n          this.isTrackPending = true;\n          try {\n            this.onInvalidate_();\n            if (\"production\" !== \"production\" && this.isTrackPending && isSpyEnabled()) ;\n          } catch (e) {\n            this.reportExceptionInDerivation_(e);\n          }\n        }\n        globalState.trackingContext = prev;\n        endBatch();\n      }\n    };\n    _proto.track = function track(fn) {\n      if (this.isDisposed) {\n        return;\n      }\n      startBatch();\n      this.isRunning = true;\n      var prevReaction = globalState.trackingContext;\n      globalState.trackingContext = this;\n      var result = trackDerivedFunction(this, fn, undefined);\n      globalState.trackingContext = prevReaction;\n      this.isRunning = false;\n      this.isTrackPending = false;\n      if (this.isDisposed) {\n        clearObserving(this);\n      }\n      if (isCaughtException(result)) {\n        this.reportExceptionInDerivation_(result.cause);\n      }\n      endBatch();\n    };\n    _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {\n      var _this = this;\n      if (this.errorHandler_) {\n        this.errorHandler_(error, this);\n        return;\n      }\n      if (globalState.disableErrorBoundaries) {\n        throw error;\n      }\n      var message = \"[mobx] uncaught error in '\" + this + \"'\";\n      if (!globalState.suppressReactionErrors) {\n        console.error(message, error);\n      }\n      globalState.globalReactionErrorHandlers.forEach(function (f) {\n        return f(error, _this);\n      });\n    };\n    _proto.dispose = function dispose() {\n      if (!this.isDisposed) {\n        this.isDisposed = true;\n        if (!this.isRunning) {\n          startBatch();\n          clearObserving(this);\n          endBatch();\n        }\n      }\n    };\n    _proto.getDisposer_ = function getDisposer_(abortSignal) {\n      var _this2 = this;\n      var dispose = function dispose() {\n        _this2.dispose();\n        abortSignal == null || abortSignal.removeEventListener == null || abortSignal.removeEventListener(\"abort\", dispose);\n      };\n      abortSignal == null || abortSignal.addEventListener == null || abortSignal.addEventListener(\"abort\", dispose);\n      dispose[$mobx] = this;\n      return dispose;\n    };\n    _proto.toString = function toString() {\n      return \"Reaction[\" + this.name_ + \"]\";\n    };\n    _proto.trace = function trace$1(enterBreakPoint) {\n    };\n    return _createClass(Reaction, [{\n      key: \"isDisposed\",\n      get: function get() {\n        return getFlag(this.flags_, Reaction.isDisposedMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, Reaction.isDisposedMask_, newValue);\n      }\n    }, {\n      key: \"isScheduled\",\n      get: function get() {\n        return getFlag(this.flags_, Reaction.isScheduledMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, Reaction.isScheduledMask_, newValue);\n      }\n    }, {\n      key: \"isTrackPending\",\n      get: function get() {\n        return getFlag(this.flags_, Reaction.isTrackPendingMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, Reaction.isTrackPendingMask_, newValue);\n      }\n    }, {\n      key: \"isRunning\",\n      get: function get() {\n        return getFlag(this.flags_, Reaction.isRunningMask_);\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, Reaction.isRunningMask_, newValue);\n      }\n    }, {\n      key: \"diffValue\",\n      get: function get() {\n        return getFlag(this.flags_, Reaction.diffValueMask_) ? 1 : 0;\n      },\n      set: function set(newValue) {\n        this.flags_ = setFlag(this.flags_, Reaction.diffValueMask_, newValue === 1 ? true : false);\n      }\n    }]);\n  })();\n  Reaction.isDisposedMask_ = 1;\n  Reaction.isScheduledMask_ = 2;\n  Reaction.isTrackPendingMask_ = 4;\n  Reaction.isRunningMask_ = 8;\n  Reaction.diffValueMask_ = 16;\n  function onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n      var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n      if (idx >= 0) {\n        globalState.globalReactionErrorHandlers.splice(idx, 1);\n      }\n    };\n  }\n  var MAX_REACTION_ITERATIONS = 100;\n  var reactionScheduler = function reactionScheduler(f) {\n    return f();\n  };\n  function runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) {\n      return;\n    }\n    reactionScheduler(runReactionsHelper);\n  }\n  function runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n      if (++iterations === MAX_REACTION_ITERATIONS) {\n        console.error(\"[mobx] cycle in reaction: \" + allReactions[0]);\n        allReactions.splice(0);\n      }\n      var remainingReactions = allReactions.splice(0);\n      for (var i = 0, l = remainingReactions.length; i < l; i++) {\n        remainingReactions[i].runReaction_();\n      }\n    }\n    globalState.isRunningReactions = false;\n  }\n  var isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\n  function setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n      return fn(function () {\n        return baseScheduler(f);\n      });\n    };\n  }\n  function isSpyEnabled() {\n    return \"production\" !== \"production\";\n  }\n  function spyReport(event) {\n    {\n      return;\n    }\n  }\n  function spyReportStart(event) {\n    {\n      return;\n    }\n  }\n  function spyReportEnd(change) {\n    {\n      return;\n    }\n  }\n  function spy(listener) {\n    {\n      console.warn(\"[mobx.spy] Is a no-op in production builds\");\n      return function () {};\n    }\n  }\n  var ACTION = \"action\";\n  var ACTION_BOUND = \"action.bound\";\n  var AUTOACTION = \"autoAction\";\n  var AUTOACTION_BOUND = \"autoAction.bound\";\n  var DEFAULT_ACTION_NAME = \"<unnamed action>\";\n  var actionAnnotation = createActionAnnotation(ACTION);\n  var actionBoundAnnotation = createActionAnnotation(ACTION_BOUND, {\n    bound: true\n  });\n  var autoActionAnnotation = createActionAnnotation(AUTOACTION, {\n    autoAction: true\n  });\n  var autoActionBoundAnnotation = createActionAnnotation(AUTOACTION_BOUND, {\n    autoAction: true,\n    bound: true\n  });\n  function createActionFactory(autoAction) {\n    var res = function action(arg1, arg2) {\n      if (isFunction(arg1)) {\n        return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction);\n      }\n      if (isFunction(arg2)) {\n        return createAction(arg1, arg2, autoAction);\n      }\n      if (is20223Decorator(arg2)) {\n        return (autoAction ? autoActionAnnotation : actionAnnotation).decorate_20223_(arg1, arg2);\n      }\n      if (isStringish(arg2)) {\n        return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);\n      }\n      if (isStringish(arg1)) {\n        return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {\n          name: arg1,\n          autoAction: autoAction\n        }));\n      }\n    };\n    return res;\n  }\n  var action = createActionFactory(false);\n  Object.assign(action, actionAnnotation);\n  var autoAction = createActionFactory(true);\n  Object.assign(autoAction, autoActionAnnotation);\n  action.bound = createDecoratorAnnotation(actionBoundAnnotation);\n  autoAction.bound = createDecoratorAnnotation(autoActionBoundAnnotation);\n  function runInAction(fn) {\n    return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, undefined);\n  }\n  function isAction(thing) {\n    return isFunction(thing) && thing.isMobxAction === true;\n  }\n  function autorun(view, opts) {\n    var _opts$name, _opts, _opts2, _opts3;\n    if (opts === void 0) {\n      opts = EMPTY_OBJECT;\n    }\n    var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : \"Autorun\";\n    var runSync = !opts.scheduler && !opts.delay;\n    var reaction;\n    if (runSync) {\n      reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n      }, opts.onError, opts.requiresObservable);\n    } else {\n      var scheduler = createSchedulerFromOptions(opts);\n      var isScheduled = false;\n      reaction = new Reaction(name, function () {\n        if (!isScheduled) {\n          isScheduled = true;\n          scheduler(function () {\n            isScheduled = false;\n            if (!reaction.isDisposed) {\n              reaction.track(reactionRunner);\n            }\n          });\n        }\n      }, opts.onError, opts.requiresObservable);\n    }\n    function reactionRunner() {\n      view(reaction);\n    }\n    if (!((_opts2 = opts) != null && (_opts2 = _opts2.signal) != null && _opts2.aborted)) {\n      reaction.schedule_();\n    }\n    return reaction.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);\n  }\n  var run = function run(f) {\n    return f();\n  };\n  function createSchedulerFromOptions(opts) {\n    return opts.scheduler ? opts.scheduler : opts.delay ? function (f) {\n      return setTimeout(f, opts.delay);\n    } : run;\n  }\n  function reaction(expression, effect, opts) {\n    var _opts$name2, _opts4, _opts5;\n    if (opts === void 0) {\n      opts = EMPTY_OBJECT;\n    }\n    var name = (_opts$name2 = opts.name) != null ? _opts$name2 : \"Reaction\";\n    var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);\n    var runSync = !opts.scheduler && !opts.delay;\n    var scheduler = createSchedulerFromOptions(opts);\n    var firstTime = true;\n    var isScheduled = false;\n    var value;\n    var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer[\"default\"];\n    var r = new Reaction(name, function () {\n      if (firstTime || runSync) {\n        reactionRunner();\n      } else if (!isScheduled) {\n        isScheduled = true;\n        scheduler(reactionRunner);\n      }\n    }, opts.onError, opts.requiresObservable);\n    function reactionRunner() {\n      isScheduled = false;\n      if (r.isDisposed) {\n        return;\n      }\n      var changed = false;\n      var oldValue = value;\n      r.track(function () {\n        var nextValue = allowStateChanges(false, function () {\n          return expression(r);\n        });\n        changed = firstTime || !equals(value, nextValue);\n        value = nextValue;\n      });\n      if (firstTime && opts.fireImmediately) {\n        effectAction(value, oldValue, r);\n      } else if (!firstTime && changed) {\n        effectAction(value, oldValue, r);\n      }\n      firstTime = false;\n    }\n    if (!((_opts4 = opts) != null && (_opts4 = _opts4.signal) != null && _opts4.aborted)) {\n      r.schedule_();\n    }\n    return r.getDisposer_((_opts5 = opts) == null ? void 0 : _opts5.signal);\n  }\n  function wrapErrorHandler(errorHandler, baseFn) {\n    return function () {\n      try {\n        return baseFn.apply(this, arguments);\n      } catch (e) {\n        errorHandler.call(this, e);\n      }\n    };\n  }\n  var ON_BECOME_OBSERVED = \"onBO\";\n  var ON_BECOME_UNOBSERVED = \"onBUO\";\n  function onBecomeObserved(thing, arg2, arg3) {\n    return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);\n  }\n  function onBecomeUnobserved(thing, arg2, arg3) {\n    return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);\n  }\n  function interceptHook(hook, thing, arg2, arg3) {\n    var atom = typeof arg3 === \"function\" ? getAtom(thing, arg2) : getAtom(thing);\n    var cb = isFunction(arg3) ? arg3 : arg2;\n    var listenersKey = hook + \"L\";\n    if (atom[listenersKey]) {\n      atom[listenersKey].add(cb);\n    } else {\n      atom[listenersKey] = new Set([cb]);\n    }\n    return function () {\n      var hookListeners = atom[listenersKey];\n      if (hookListeners) {\n        hookListeners[\"delete\"](cb);\n        if (hookListeners.size === 0) {\n          delete atom[listenersKey];\n        }\n      }\n    };\n  }\n  var NEVER = \"never\";\n  var ALWAYS = \"always\";\n  var OBSERVED = \"observed\";\n  function configure(options) {\n    if (options.isolateGlobalState === true) {\n      isolateGlobalState();\n    }\n    var useProxies = options.useProxies, enforceActions = options.enforceActions;\n    if (useProxies !== undefined) {\n      globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== \"undefined\";\n    }\n    if (useProxies === \"ifavailable\") {\n      globalState.verifyProxies = true;\n    }\n    if (enforceActions !== undefined) {\n      var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;\n      globalState.enforceActions = ea;\n      globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;\n    }\n    [\"computedRequiresReaction\", \"reactionRequiresObservable\", \"observableRequiresReaction\", \"disableErrorBoundaries\", \"safeDescriptors\"].forEach(function (key) {\n      if ((key in options)) {\n        globalState[key] = !!options[key];\n      }\n    });\n    globalState.allowStateReads = !globalState.observableRequiresReaction;\n    if (options.reactionScheduler) {\n      setReactionScheduler(options.reactionScheduler);\n    }\n  }\n  function extendObservable(target, properties, annotations, options) {\n    var descriptors = getOwnPropertyDescriptors(properties);\n    initObservable(function () {\n      var adm = asObservableObject(target, options)[$mobx];\n      ownKeys(descriptors).forEach(function (key) {\n        adm.extend_(key, descriptors[key], !annotations ? true : (key in annotations) ? annotations[key] : true);\n      });\n    });\n    return target;\n  }\n  function getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n  }\n  function nodeToDependencyTree(node) {\n    var result = {\n      name: node.name_\n    };\n    if (node.observing_ && node.observing_.length > 0) {\n      result.dependencies = unique(node.observing_).map(nodeToDependencyTree);\n    }\n    return result;\n  }\n  function getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n  }\n  function nodeToObserverTree(node) {\n    var result = {\n      name: node.name_\n    };\n    if (hasObservers(node)) {\n      result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);\n    }\n    return result;\n  }\n  function unique(list) {\n    return Array.from(new Set(list));\n  }\n  var generatorId = 0;\n  function FlowCancellationError() {\n    this.message = \"FLOW_CANCELLED\";\n  }\n  FlowCancellationError.prototype = Object.create(Error.prototype);\n  function isFlowCancellationError(error) {\n    return error instanceof FlowCancellationError;\n  }\n  var flowAnnotation = createFlowAnnotation(\"flow\");\n  var flowBoundAnnotation = createFlowAnnotation(\"flow.bound\", {\n    bound: true\n  });\n  var flow = Object.assign(function flow(arg1, arg2) {\n    if (is20223Decorator(arg2)) {\n      return flowAnnotation.decorate_20223_(arg1, arg2);\n    }\n    if (isStringish(arg2)) {\n      return storeAnnotation(arg1, arg2, flowAnnotation);\n    }\n    var generator = arg1;\n    var name = generator.name || \"<unnamed flow>\";\n    var res = function res() {\n      var ctx = this;\n      var args = arguments;\n      var runId = ++generatorId;\n      var gen = action(name + \" - runid: \" + runId + \" - init\", generator).apply(ctx, args);\n      var rejector;\n      var pendingPromise = undefined;\n      var promise = new Promise(function (resolve, reject) {\n        var stepId = 0;\n        rejector = reject;\n        function onFulfilled(res) {\n          pendingPromise = undefined;\n          var ret;\n          try {\n            ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen.next).call(gen, res);\n          } catch (e) {\n            return reject(e);\n          }\n          next(ret);\n        }\n        function onRejected(err) {\n          pendingPromise = undefined;\n          var ret;\n          try {\n            ret = action(name + \" - runid: \" + runId + \" - yield \" + stepId++, gen[\"throw\"]).call(gen, err);\n          } catch (e) {\n            return reject(e);\n          }\n          next(ret);\n        }\n        function next(ret) {\n          if (isFunction(ret == null ? void 0 : ret.then)) {\n            ret.then(next, reject);\n            return;\n          }\n          if (ret.done) {\n            return resolve(ret.value);\n          }\n          pendingPromise = Promise.resolve(ret.value);\n          return pendingPromise.then(onFulfilled, onRejected);\n        }\n        onFulfilled(undefined);\n      });\n      promise.cancel = action(name + \" - runid: \" + runId + \" - cancel\", function () {\n        try {\n          if (pendingPromise) {\n            cancelPromise(pendingPromise);\n          }\n          var _res = gen[\"return\"](undefined);\n          var yieldedPromise = Promise.resolve(_res.value);\n          yieldedPromise.then(noop, noop);\n          cancelPromise(yieldedPromise);\n          rejector(new FlowCancellationError());\n        } catch (e) {\n          rejector(e);\n        }\n      });\n      return promise;\n    };\n    res.isMobXFlow = true;\n    return res;\n  }, flowAnnotation);\n  flow.bound = createDecoratorAnnotation(flowBoundAnnotation);\n  function cancelPromise(promise) {\n    if (isFunction(promise.cancel)) {\n      promise.cancel();\n    }\n  }\n  function flowResult(result) {\n    return result;\n  }\n  function isFlow(fn) {\n    return (fn == null ? void 0 : fn.isMobXFlow) === true;\n  }\n  function interceptReads(thing, propOrHandler, handler) {\n    var target;\n    if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {\n      target = getAdministration(thing);\n    } else if (isObservableObject(thing)) {\n      target = getAdministration(thing, propOrHandler);\n    } else ;\n    target.dehancer = typeof propOrHandler === \"function\" ? propOrHandler : handler;\n    return function () {\n      target.dehancer = undefined;\n    };\n  }\n  function intercept(thing, propOrHandler, handler) {\n    if (isFunction(handler)) {\n      return interceptProperty(thing, propOrHandler, handler);\n    } else {\n      return interceptInterceptable(thing, propOrHandler);\n    }\n  }\n  function interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept_(handler);\n  }\n  function interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept_(handler);\n  }\n  function _isComputed(value, property) {\n    if (property === undefined) {\n      return isComputedValue(value);\n    }\n    if (isObservableObject(value) === false) {\n      return false;\n    }\n    if (!value[$mobx].values_.has(property)) {\n      return false;\n    }\n    var atom = getAtom(value, property);\n    return isComputedValue(atom);\n  }\n  function isComputed(value) {\n    return _isComputed(value);\n  }\n  function isComputedProp(value, propName) {\n    return _isComputed(value, propName);\n  }\n  function _isObservable(value, property) {\n    if (!value) {\n      return false;\n    }\n    if (property !== undefined) {\n      if (isObservableObject(value)) {\n        return value[$mobx].values_.has(property);\n      }\n      return false;\n    }\n    return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);\n  }\n  function isObservable(value) {\n    return _isObservable(value);\n  }\n  function isObservableProp(value, propName) {\n    return _isObservable(value, propName);\n  }\n  function keys(obj) {\n    if (isObservableObject(obj)) {\n      return obj[$mobx].keys_();\n    }\n    if (isObservableMap(obj) || isObservableSet(obj)) {\n      return Array.from(obj.keys());\n    }\n    if (isObservableArray(obj)) {\n      return obj.map(function (_, index) {\n        return index;\n      });\n    }\n    die(5);\n  }\n  function values(obj) {\n    if (isObservableObject(obj)) {\n      return keys(obj).map(function (key) {\n        return obj[key];\n      });\n    }\n    if (isObservableMap(obj)) {\n      return keys(obj).map(function (key) {\n        return obj.get(key);\n      });\n    }\n    if (isObservableSet(obj)) {\n      return Array.from(obj.values());\n    }\n    if (isObservableArray(obj)) {\n      return obj.slice();\n    }\n    die(6);\n  }\n  function entries(obj) {\n    if (isObservableObject(obj)) {\n      return keys(obj).map(function (key) {\n        return [key, obj[key]];\n      });\n    }\n    if (isObservableMap(obj)) {\n      return keys(obj).map(function (key) {\n        return [key, obj.get(key)];\n      });\n    }\n    if (isObservableSet(obj)) {\n      return Array.from(obj.entries());\n    }\n    if (isObservableArray(obj)) {\n      return obj.map(function (key, index) {\n        return [index, key];\n      });\n    }\n    die(7);\n  }\n  function set(obj, key, value) {\n    if (arguments.length === 2 && !isObservableSet(obj)) {\n      startBatch();\n      var _values = key;\n      try {\n        for (var _key in _values) {\n          set(obj, _key, _values[_key]);\n        }\n      } finally {\n        endBatch();\n      }\n      return;\n    }\n    if (isObservableObject(obj)) {\n      obj[$mobx].set_(key, value);\n    } else if (isObservableMap(obj)) {\n      obj.set(key, value);\n    } else if (isObservableSet(obj)) {\n      obj.add(key);\n    } else if (isObservableArray(obj)) {\n      if (typeof key !== \"number\") {\n        key = parseInt(key, 10);\n      }\n      if (key < 0) {\n        die(\"Invalid index: '\" + key + \"'\");\n      }\n      startBatch();\n      if (key >= obj.length) {\n        obj.length = key + 1;\n      }\n      obj[key] = value;\n      endBatch();\n    } else {\n      die(8);\n    }\n  }\n  function remove(obj, key) {\n    if (isObservableObject(obj)) {\n      obj[$mobx].delete_(key);\n    } else if (isObservableMap(obj)) {\n      obj[\"delete\"](key);\n    } else if (isObservableSet(obj)) {\n      obj[\"delete\"](key);\n    } else if (isObservableArray(obj)) {\n      if (typeof key !== \"number\") {\n        key = parseInt(key, 10);\n      }\n      obj.splice(key, 1);\n    } else {\n      die(9);\n    }\n  }\n  function has(obj, key) {\n    if (isObservableObject(obj)) {\n      return obj[$mobx].has_(key);\n    } else if (isObservableMap(obj)) {\n      return obj.has(key);\n    } else if (isObservableSet(obj)) {\n      return obj.has(key);\n    } else if (isObservableArray(obj)) {\n      return key >= 0 && key < obj.length;\n    }\n    die(10);\n  }\n  function get(obj, key) {\n    if (!has(obj, key)) {\n      return undefined;\n    }\n    if (isObservableObject(obj)) {\n      return obj[$mobx].get_(key);\n    } else if (isObservableMap(obj)) {\n      return obj.get(key);\n    } else if (isObservableArray(obj)) {\n      return obj[key];\n    }\n    die(11);\n  }\n  function apiDefineProperty(obj, key, descriptor) {\n    if (isObservableObject(obj)) {\n      return obj[$mobx].defineProperty_(key, descriptor);\n    }\n    die(39);\n  }\n  function apiOwnKeys(obj) {\n    if (isObservableObject(obj)) {\n      return obj[$mobx].ownKeys_();\n    }\n    die(38);\n  }\n  function observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (isFunction(cbOrFire)) {\n      return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);\n    } else {\n      return observeObservable(thing, propOrCb, cbOrFire);\n    }\n  }\n  function observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe_(listener, fireImmediately);\n  }\n  function observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe_(listener, fireImmediately);\n  }\n  function cache(map, key, value) {\n    map.set(key, value);\n    return value;\n  }\n  function toJSHelper(source, __alreadySeen) {\n    if (source == null || typeof source !== \"object\" || source instanceof Date || !isObservable(source)) {\n      return source;\n    }\n    if (isObservableValue(source) || isComputedValue(source)) {\n      return toJSHelper(source.get(), __alreadySeen);\n    }\n    if (__alreadySeen.has(source)) {\n      return __alreadySeen.get(source);\n    }\n    if (isObservableArray(source)) {\n      var res = cache(__alreadySeen, source, new Array(source.length));\n      source.forEach(function (value, idx) {\n        res[idx] = toJSHelper(value, __alreadySeen);\n      });\n      return res;\n    }\n    if (isObservableSet(source)) {\n      var _res = cache(__alreadySeen, source, new Set());\n      source.forEach(function (value) {\n        _res.add(toJSHelper(value, __alreadySeen));\n      });\n      return _res;\n    }\n    if (isObservableMap(source)) {\n      var _res2 = cache(__alreadySeen, source, new Map());\n      source.forEach(function (value, key) {\n        _res2.set(key, toJSHelper(value, __alreadySeen));\n      });\n      return _res2;\n    } else {\n      var _res3 = cache(__alreadySeen, source, {});\n      apiOwnKeys(source).forEach(function (key) {\n        if (objectPrototype.propertyIsEnumerable.call(source, key)) {\n          _res3[key] = toJSHelper(source[key], __alreadySeen);\n        }\n      });\n      return _res3;\n    }\n  }\n  function toJS(source, options) {\n    return toJSHelper(source, new Map());\n  }\n  function trace() {\n    {\n      return;\n    }\n  }\n  function transaction(action, thisArg) {\n    if (thisArg === void 0) {\n      thisArg = undefined;\n    }\n    startBatch();\n    try {\n      return action.apply(thisArg);\n    } finally {\n      endBatch();\n    }\n  }\n  function when(predicate, arg1, arg2) {\n    if (arguments.length === 1 || arg1 && typeof arg1 === \"object\") {\n      return whenPromise(predicate, arg1);\n    }\n    return _when(predicate, arg1, arg2 || ({}));\n  }\n  function _when(predicate, effect, opts) {\n    var timeoutHandle;\n    if (typeof opts.timeout === \"number\") {\n      var error = new Error(\"WHEN_TIMEOUT\");\n      timeoutHandle = setTimeout(function () {\n        if (!disposer[$mobx].isDisposed) {\n          disposer();\n          if (opts.onError) {\n            opts.onError(error);\n          } else {\n            throw error;\n          }\n        }\n      }, opts.timeout);\n    }\n    opts.name = \"When\";\n    var effectAction = createAction(\"When-effect\", effect);\n    var disposer = autorun(function (r) {\n      var cond = allowStateChanges(false, predicate);\n      if (cond) {\n        r.dispose();\n        if (timeoutHandle) {\n          clearTimeout(timeoutHandle);\n        }\n        effectAction();\n      }\n    }, opts);\n    return disposer;\n  }\n  function whenPromise(predicate, opts) {\n    var _opts$signal;\n    if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {\n      return Object.assign(Promise.reject(new Error(\"WHEN_ABORTED\")), {\n        cancel: function cancel() {\n          return null;\n        }\n      });\n    }\n    var cancel;\n    var abort;\n    var res = new Promise(function (resolve, reject) {\n      var _opts$signal2;\n      var disposer = _when(predicate, resolve, _extends({}, opts, {\n        onError: reject\n      }));\n      cancel = function cancel() {\n        disposer();\n        reject(new Error(\"WHEN_CANCELLED\"));\n      };\n      abort = function abort() {\n        disposer();\n        reject(new Error(\"WHEN_ABORTED\"));\n      };\n      opts == null || (_opts$signal2 = opts.signal) == null || _opts$signal2.addEventListener == null || _opts$signal2.addEventListener(\"abort\", abort);\n    })[\"finally\"](function () {\n      var _opts$signal3;\n      return opts == null || (_opts$signal3 = opts.signal) == null || _opts$signal3.removeEventListener == null ? void 0 : _opts$signal3.removeEventListener(\"abort\", abort);\n    });\n    res.cancel = cancel;\n    return res;\n  }\n  function getAdm(target) {\n    return target[$mobx];\n  }\n  var objectProxyTraps = {\n    has: function has(target, name) {\n      return getAdm(target).has_(name);\n    },\n    get: function get(target, name) {\n      return getAdm(target).get_(name);\n    },\n    set: function set(target, name, value) {\n      var _getAdm$set_;\n      if (!isStringish(name)) {\n        return false;\n      }\n      return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;\n    },\n    deleteProperty: function deleteProperty(target, name) {\n      var _getAdm$delete_;\n      if (!isStringish(name)) {\n        return false;\n      }\n      return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;\n    },\n    defineProperty: function defineProperty(target, name, descriptor) {\n      var _getAdm$definePropert;\n      return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;\n    },\n    ownKeys: function ownKeys(target) {\n      return getAdm(target).ownKeys_();\n    },\n    preventExtensions: function preventExtensions(target) {\n      die(13);\n    }\n  };\n  function asDynamicObservableObject(target, options) {\n    var _target$$mobx, _target$$mobx$proxy_;\n    assertProxies();\n    target = asObservableObject(target, options);\n    return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);\n  }\n  function hasInterceptors(interceptable) {\n    return interceptable.interceptors_ !== undefined && interceptable.interceptors_.length > 0;\n  }\n  function registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);\n    interceptors.push(handler);\n    return once(function () {\n      var idx = interceptors.indexOf(handler);\n      if (idx !== -1) {\n        interceptors.splice(idx, 1);\n      }\n    });\n  }\n  function interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n      var interceptors = [].concat(interceptable.interceptors_ || []);\n      for (var i = 0, l = interceptors.length; i < l; i++) {\n        change = interceptors[i](change);\n        if (change && !change.type) {\n          die(14);\n        }\n        if (!change) {\n          break;\n        }\n      }\n      return change;\n    } finally {\n      untrackedEnd(prevU);\n    }\n  }\n  function hasListeners(listenable) {\n    return listenable.changeListeners_ !== undefined && listenable.changeListeners_.length > 0;\n  }\n  function registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);\n    listeners.push(handler);\n    return once(function () {\n      var idx = listeners.indexOf(handler);\n      if (idx !== -1) {\n        listeners.splice(idx, 1);\n      }\n    });\n  }\n  function notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners_;\n    if (!listeners) {\n      return;\n    }\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i](change);\n    }\n    untrackedEnd(prevU);\n  }\n  function makeObservable(target, annotations, options) {\n    initObservable(function () {\n      var _annotations;\n      var adm = asObservableObject(target, options)[$mobx];\n      if (\"production\" !== \"production\" && annotations && target[storedAnnotationsSymbol]) ;\n      (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);\n      ownKeys(annotations).forEach(function (key) {\n        return adm.make_(key, annotations[key]);\n      });\n    });\n    return target;\n  }\n  var keysSymbol = Symbol(\"mobx-keys\");\n  function makeAutoObservable(target, overrides, options) {\n    if (isPlainObject(target)) {\n      return extendObservable(target, target, overrides, options);\n    }\n    initObservable(function () {\n      var adm = asObservableObject(target, options)[$mobx];\n      if (!target[keysSymbol]) {\n        var proto = Object.getPrototypeOf(target);\n        var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));\n        keys[\"delete\"](\"constructor\");\n        keys[\"delete\"]($mobx);\n        addHiddenProp(proto, keysSymbol, keys);\n      }\n      target[keysSymbol].forEach(function (key) {\n        return adm.make_(key, !overrides ? true : (key in overrides) ? overrides[key] : true);\n      });\n    });\n    return target;\n  }\n  var SPLICE = \"splice\";\n  var UPDATE = \"update\";\n  var MAX_SPLICE_SIZE = 10000;\n  var arrayTraps = {\n    get: function get(target, name) {\n      var adm = target[$mobx];\n      if (name === $mobx) {\n        return adm;\n      }\n      if (name === \"length\") {\n        return adm.getArrayLength_();\n      }\n      if (typeof name === \"string\" && !isNaN(name)) {\n        return adm.get_(parseInt(name));\n      }\n      if (hasProp(arrayExtensions, name)) {\n        return arrayExtensions[name];\n      }\n      return target[name];\n    },\n    set: function set(target, name, value) {\n      var adm = target[$mobx];\n      if (name === \"length\") {\n        adm.setArrayLength_(value);\n      }\n      if (typeof name === \"symbol\" || isNaN(name)) {\n        target[name] = value;\n      } else {\n        adm.set_(parseInt(name), value);\n      }\n      return true;\n    },\n    preventExtensions: function preventExtensions() {\n      die(15);\n    }\n  };\n  var ObservableArrayAdministration = (function () {\n    function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {\n      if (name === void 0) {\n        name = \"ObservableArray\";\n      }\n      this.owned_ = void 0;\n      this.legacyMode_ = void 0;\n      this.atom_ = void 0;\n      this.values_ = [];\n      this.interceptors_ = void 0;\n      this.changeListeners_ = void 0;\n      this.enhancer_ = void 0;\n      this.dehancer = void 0;\n      this.proxy_ = void 0;\n      this.lastKnownLength_ = 0;\n      this.owned_ = owned_;\n      this.legacyMode_ = legacyMode_;\n      this.atom_ = new Atom(name);\n      this.enhancer_ = function (newV, oldV) {\n        return enhancer(newV, oldV, \"ObservableArray[..]\");\n      };\n    }\n    var _proto = ObservableArrayAdministration.prototype;\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n      if (this.dehancer !== undefined) {\n        return this.dehancer(value);\n      }\n      return value;\n    };\n    _proto.dehanceValues_ = function dehanceValues_(values) {\n      if (this.dehancer !== undefined && values.length > 0) {\n        return values.map(this.dehancer);\n      }\n      return values;\n    };\n    _proto.intercept_ = function intercept_(handler) {\n      return registerInterceptor(this, handler);\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n      if (fireImmediately === void 0) {\n        fireImmediately = false;\n      }\n      if (fireImmediately) {\n        listener({\n          observableKind: \"array\",\n          object: this.proxy_,\n          debugObjectName: this.atom_.name_,\n          type: \"splice\",\n          index: 0,\n          added: this.values_.slice(),\n          addedCount: this.values_.length,\n          removed: [],\n          removedCount: 0\n        });\n      }\n      return registerListener(this, listener);\n    };\n    _proto.getArrayLength_ = function getArrayLength_() {\n      this.atom_.reportObserved();\n      return this.values_.length;\n    };\n    _proto.setArrayLength_ = function setArrayLength_(newLength) {\n      if (typeof newLength !== \"number\" || isNaN(newLength) || newLength < 0) {\n        die(\"Out of range: \" + newLength);\n      }\n      var currentLength = this.values_.length;\n      if (newLength === currentLength) {\n        return;\n      } else if (newLength > currentLength) {\n        var newItems = new Array(newLength - currentLength);\n        for (var i = 0; i < newLength - currentLength; i++) {\n          newItems[i] = undefined;\n        }\n        this.spliceWithArray_(currentLength, 0, newItems);\n      } else {\n        this.spliceWithArray_(newLength, currentLength - newLength);\n      }\n    };\n    _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {\n      if (oldLength !== this.lastKnownLength_) {\n        die(16);\n      }\n      this.lastKnownLength_ += delta;\n      if (this.legacyMode_ && delta > 0) {\n        reserveArrayBuffer(oldLength + delta + 1);\n      }\n    };\n    _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {\n      var _this = this;\n      checkIfStateModificationsAreAllowed(this.atom_);\n      var length = this.values_.length;\n      if (index === undefined) {\n        index = 0;\n      } else if (index > length) {\n        index = length;\n      } else if (index < 0) {\n        index = Math.max(0, length + index);\n      }\n      if (arguments.length === 1) {\n        deleteCount = length - index;\n      } else if (deleteCount === undefined || deleteCount === null) {\n        deleteCount = 0;\n      } else {\n        deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n      }\n      if (newItems === undefined) {\n        newItems = EMPTY_ARRAY;\n      }\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          object: this.proxy_,\n          type: SPLICE,\n          index: index,\n          removedCount: deleteCount,\n          added: newItems\n        });\n        if (!change) {\n          return EMPTY_ARRAY;\n        }\n        deleteCount = change.removedCount;\n        newItems = change.added;\n      }\n      newItems = newItems.length === 0 ? newItems : newItems.map(function (v) {\n        return _this.enhancer_(v, undefined);\n      });\n      if (this.legacyMode_ || \"production\" !== \"production\") {\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength_(length, lengthDelta);\n      }\n      var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);\n      if (deleteCount !== 0 || newItems.length !== 0) {\n        this.notifyArraySplice_(index, newItems, res);\n      }\n      return this.dehanceValues_(res);\n    };\n    _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {\n      if (newItems.length < MAX_SPLICE_SIZE) {\n        var _this$values_;\n        return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));\n      } else {\n        var res = this.values_.slice(index, index + deleteCount);\n        var oldItems = this.values_.slice(index + deleteCount);\n        this.values_.length += newItems.length - deleteCount;\n        for (var i = 0; i < newItems.length; i++) {\n          this.values_[index + i] = newItems[i];\n        }\n        for (var _i = 0; _i < oldItems.length; _i++) {\n          this.values_[index + newItems.length + _i] = oldItems[_i];\n        }\n        return res;\n      }\n    };\n    _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {\n      var notifySpy = !this.owned_ && isSpyEnabled();\n      var notify = hasListeners(this);\n      var change = notify || notifySpy ? {\n        observableKind: \"array\",\n        object: this.proxy_,\n        type: UPDATE,\n        debugObjectName: this.atom_.name_,\n        index: index,\n        newValue: newValue,\n        oldValue: oldValue\n      } : null;\n      this.atom_.reportChanged();\n      if (notify) {\n        notifyListeners(this, change);\n      }\n    };\n    _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {\n      var notifySpy = !this.owned_ && isSpyEnabled();\n      var notify = hasListeners(this);\n      var change = notify || notifySpy ? {\n        observableKind: \"array\",\n        object: this.proxy_,\n        debugObjectName: this.atom_.name_,\n        type: SPLICE,\n        index: index,\n        removed: removed,\n        added: added,\n        removedCount: removed.length,\n        addedCount: added.length\n      } : null;\n      this.atom_.reportChanged();\n      if (notify) {\n        notifyListeners(this, change);\n      }\n    };\n    _proto.get_ = function get_(index) {\n      if (this.legacyMode_ && index >= this.values_.length) {\n        console.warn(\"[mobx] Out of bounds read: \" + index);\n        return undefined;\n      }\n      this.atom_.reportObserved();\n      return this.dehanceValue_(this.values_[index]);\n    };\n    _proto.set_ = function set_(index, newValue) {\n      var values = this.values_;\n      if (this.legacyMode_ && index > values.length) {\n        die(17, index, values.length);\n      }\n      if (index < values.length) {\n        checkIfStateModificationsAreAllowed(this.atom_);\n        var oldValue = values[index];\n        if (hasInterceptors(this)) {\n          var change = interceptChange(this, {\n            type: UPDATE,\n            object: this.proxy_,\n            index: index,\n            newValue: newValue\n          });\n          if (!change) {\n            return;\n          }\n          newValue = change.newValue;\n        }\n        newValue = this.enhancer_(newValue, oldValue);\n        var changed = newValue !== oldValue;\n        if (changed) {\n          values[index] = newValue;\n          this.notifyArrayChildUpdate_(index, newValue, oldValue);\n        }\n      } else {\n        var newItems = new Array(index + 1 - values.length);\n        for (var i = 0; i < newItems.length - 1; i++) {\n          newItems[i] = undefined;\n        }\n        newItems[newItems.length - 1] = newValue;\n        this.spliceWithArray_(values.length, 0, newItems);\n      }\n    };\n    return ObservableArrayAdministration;\n  })();\n  function createObservableArray(initialValues, enhancer, name, owned) {\n    if (name === void 0) {\n      name = \"ObservableArray\";\n    }\n    if (owned === void 0) {\n      owned = false;\n    }\n    assertProxies();\n    return initObservable(function () {\n      var adm = new ObservableArrayAdministration(name, enhancer, owned, false);\n      addHiddenFinalProp(adm.values_, $mobx, adm);\n      var proxy = new Proxy(adm.values_, arrayTraps);\n      adm.proxy_ = proxy;\n      if (initialValues && initialValues.length) {\n        adm.spliceWithArray_(0, 0, initialValues);\n      }\n      return proxy;\n    });\n  }\n  var arrayExtensions = {\n    clear: function clear() {\n      return this.splice(0);\n    },\n    replace: function replace(newItems) {\n      var adm = this[$mobx];\n      return adm.spliceWithArray_(0, adm.values_.length, newItems);\n    },\n    toJSON: function toJSON() {\n      return this.slice();\n    },\n    splice: function splice(index, deleteCount) {\n      for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        newItems[_key - 2] = arguments[_key];\n      }\n      var adm = this[$mobx];\n      switch (arguments.length) {\n        case 0:\n          return [];\n        case 1:\n          return adm.spliceWithArray_(index);\n        case 2:\n          return adm.spliceWithArray_(index, deleteCount);\n      }\n      return adm.spliceWithArray_(index, deleteCount, newItems);\n    },\n    spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {\n      return this[$mobx].spliceWithArray_(index, deleteCount, newItems);\n    },\n    push: function push() {\n      var adm = this[$mobx];\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n      adm.spliceWithArray_(adm.values_.length, 0, items);\n      return adm.values_.length;\n    },\n    pop: function pop() {\n      return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];\n    },\n    shift: function shift() {\n      return this.splice(0, 1)[0];\n    },\n    unshift: function unshift() {\n      var adm = this[$mobx];\n      for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        items[_key3] = arguments[_key3];\n      }\n      adm.spliceWithArray_(0, 0, items);\n      return adm.values_.length;\n    },\n    reverse: function reverse() {\n      if (globalState.trackingDerivation) {\n        die(37, \"reverse\");\n      }\n      this.replace(this.slice().reverse());\n      return this;\n    },\n    sort: function sort() {\n      if (globalState.trackingDerivation) {\n        die(37, \"sort\");\n      }\n      var copy = this.slice();\n      copy.sort.apply(copy, arguments);\n      this.replace(copy);\n      return this;\n    },\n    remove: function remove(value) {\n      var adm = this[$mobx];\n      var idx = adm.dehanceValues_(adm.values_).indexOf(value);\n      if (idx > -1) {\n        this.splice(idx, 1);\n        return true;\n      }\n      return false;\n    }\n  };\n  addArrayExtension(\"at\", simpleFunc);\n  addArrayExtension(\"concat\", simpleFunc);\n  addArrayExtension(\"flat\", simpleFunc);\n  addArrayExtension(\"includes\", simpleFunc);\n  addArrayExtension(\"indexOf\", simpleFunc);\n  addArrayExtension(\"join\", simpleFunc);\n  addArrayExtension(\"lastIndexOf\", simpleFunc);\n  addArrayExtension(\"slice\", simpleFunc);\n  addArrayExtension(\"toString\", simpleFunc);\n  addArrayExtension(\"toLocaleString\", simpleFunc);\n  addArrayExtension(\"toSorted\", simpleFunc);\n  addArrayExtension(\"toSpliced\", simpleFunc);\n  addArrayExtension(\"with\", simpleFunc);\n  addArrayExtension(\"every\", mapLikeFunc);\n  addArrayExtension(\"filter\", mapLikeFunc);\n  addArrayExtension(\"find\", mapLikeFunc);\n  addArrayExtension(\"findIndex\", mapLikeFunc);\n  addArrayExtension(\"findLast\", mapLikeFunc);\n  addArrayExtension(\"findLastIndex\", mapLikeFunc);\n  addArrayExtension(\"flatMap\", mapLikeFunc);\n  addArrayExtension(\"forEach\", mapLikeFunc);\n  addArrayExtension(\"map\", mapLikeFunc);\n  addArrayExtension(\"some\", mapLikeFunc);\n  addArrayExtension(\"toReversed\", mapLikeFunc);\n  addArrayExtension(\"reduce\", reduceLikeFunc);\n  addArrayExtension(\"reduceRight\", reduceLikeFunc);\n  function addArrayExtension(funcName, funcFactory) {\n    if (typeof Array.prototype[funcName] === \"function\") {\n      arrayExtensions[funcName] = funcFactory(funcName);\n    }\n  }\n  function simpleFunc(funcName) {\n    return function () {\n      var adm = this[$mobx];\n      adm.atom_.reportObserved();\n      var dehancedValues = adm.dehanceValues_(adm.values_);\n      return dehancedValues[funcName].apply(dehancedValues, arguments);\n    };\n  }\n  function mapLikeFunc(funcName) {\n    return function (callback, thisArg) {\n      var _this2 = this;\n      var adm = this[$mobx];\n      adm.atom_.reportObserved();\n      var dehancedValues = adm.dehanceValues_(adm.values_);\n      return dehancedValues[funcName](function (element, index) {\n        return callback.call(thisArg, element, index, _this2);\n      });\n    };\n  }\n  function reduceLikeFunc(funcName) {\n    return function () {\n      var _this3 = this;\n      var adm = this[$mobx];\n      adm.atom_.reportObserved();\n      var dehancedValues = adm.dehanceValues_(adm.values_);\n      var callback = arguments[0];\n      arguments[0] = function (accumulator, currentValue, index) {\n        return callback(accumulator, currentValue, index, _this3);\n      };\n      return dehancedValues[funcName].apply(dehancedValues, arguments);\n    };\n  }\n  var isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\n  function isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);\n  }\n  var ObservableMapMarker = {};\n  var ADD = \"add\";\n  var DELETE = \"delete\";\n  var ObservableMap = (function () {\n    function ObservableMap(initialData, enhancer_, name_) {\n      var _this = this;\n      if (enhancer_ === void 0) {\n        enhancer_ = deepEnhancer;\n      }\n      if (name_ === void 0) {\n        name_ = \"ObservableMap\";\n      }\n      this.enhancer_ = void 0;\n      this.name_ = void 0;\n      this[$mobx] = ObservableMapMarker;\n      this.data_ = void 0;\n      this.hasMap_ = void 0;\n      this.keysAtom_ = void 0;\n      this.interceptors_ = void 0;\n      this.changeListeners_ = void 0;\n      this.dehancer = void 0;\n      this.enhancer_ = enhancer_;\n      this.name_ = name_;\n      if (!isFunction(Map)) {\n        die(18);\n      }\n      initObservable(function () {\n        _this.keysAtom_ = createAtom(\"production\" !== \"production\" ? _this.name_ + \".keys()\" : \"ObservableMap.keys()\");\n        _this.data_ = new Map();\n        _this.hasMap_ = new Map();\n        if (initialData) {\n          _this.merge(initialData);\n        }\n      });\n    }\n    var _proto = ObservableMap.prototype;\n    _proto.has_ = function has_(key) {\n      return this.data_.has(key);\n    };\n    _proto.has = function has(key) {\n      var _this2 = this;\n      if (!globalState.trackingDerivation) {\n        return this.has_(key);\n      }\n      var entry = this.hasMap_.get(key);\n      if (!entry) {\n        var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, \"ObservableMap.key?\", false);\n        this.hasMap_.set(key, newEntry);\n        onBecomeUnobserved(newEntry, function () {\n          return _this2.hasMap_[\"delete\"](key);\n        });\n      }\n      return entry.get();\n    };\n    _proto.set = function set(key, value) {\n      var hasKey = this.has_(key);\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          type: hasKey ? UPDATE : ADD,\n          object: this,\n          newValue: value,\n          name: key\n        });\n        if (!change) {\n          return this;\n        }\n        value = change.newValue;\n      }\n      if (hasKey) {\n        this.updateValue_(key, value);\n      } else {\n        this.addValue_(key, value);\n      }\n      return this;\n    };\n    _proto[\"delete\"] = function _delete(key) {\n      var _this3 = this;\n      checkIfStateModificationsAreAllowed(this.keysAtom_);\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          type: DELETE,\n          object: this,\n          name: key\n        });\n        if (!change) {\n          return false;\n        }\n      }\n      if (this.has_(key)) {\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var _change = notify || notifySpy ? {\n          observableKind: \"map\",\n          debugObjectName: this.name_,\n          type: DELETE,\n          object: this,\n          oldValue: this.data_.get(key).value_,\n          name: key\n        } : null;\n        transaction(function () {\n          var _this3$hasMap_$get;\n          _this3.keysAtom_.reportChanged();\n          (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null || _this3$hasMap_$get.setNewValue_(false);\n          var observable = _this3.data_.get(key);\n          observable.setNewValue_(undefined);\n          _this3.data_[\"delete\"](key);\n        });\n        if (notify) {\n          notifyListeners(this, _change);\n        }\n        return true;\n      }\n      return false;\n    };\n    _proto.updateValue_ = function updateValue_(key, newValue) {\n      var observable = this.data_.get(key);\n      newValue = observable.prepareNewValue_(newValue);\n      if (newValue !== globalState.UNCHANGED) {\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n          observableKind: \"map\",\n          debugObjectName: this.name_,\n          type: UPDATE,\n          object: this,\n          oldValue: observable.value_,\n          name: key,\n          newValue: newValue\n        } : null;\n        observable.setNewValue_(newValue);\n        if (notify) {\n          notifyListeners(this, change);\n        }\n      }\n    };\n    _proto.addValue_ = function addValue_(key, newValue) {\n      var _this4 = this;\n      checkIfStateModificationsAreAllowed(this.keysAtom_);\n      transaction(function () {\n        var _this4$hasMap_$get;\n        var observable = new ObservableValue(newValue, _this4.enhancer_, \"ObservableMap.key\", false);\n        _this4.data_.set(key, observable);\n        newValue = observable.value_;\n        (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null || _this4$hasMap_$get.setNewValue_(true);\n        _this4.keysAtom_.reportChanged();\n      });\n      var notifySpy = isSpyEnabled();\n      var notify = hasListeners(this);\n      var change = notify || notifySpy ? {\n        observableKind: \"map\",\n        debugObjectName: this.name_,\n        type: ADD,\n        object: this,\n        name: key,\n        newValue: newValue\n      } : null;\n      if (notify) {\n        notifyListeners(this, change);\n      }\n    };\n    _proto.get = function get(key) {\n      if (this.has(key)) {\n        return this.dehanceValue_(this.data_.get(key).get());\n      }\n      return this.dehanceValue_(undefined);\n    };\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n      if (this.dehancer !== undefined) {\n        return this.dehancer(value);\n      }\n      return value;\n    };\n    _proto.keys = function keys() {\n      this.keysAtom_.reportObserved();\n      return this.data_.keys();\n    };\n    _proto.values = function values() {\n      var self = this;\n      var keys = this.keys();\n      return makeIterableForMap({\n        next: function next() {\n          var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;\n          return {\n            done: done,\n            value: done ? undefined : self.get(value)\n          };\n        }\n      });\n    };\n    _proto.entries = function entries() {\n      var self = this;\n      var keys = this.keys();\n      return makeIterableForMap({\n        next: function next() {\n          var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;\n          return {\n            done: done,\n            value: done ? undefined : [value, self.get(value)]\n          };\n        }\n      });\n    };\n    _proto[Symbol.iterator] = function () {\n      return this.entries();\n    };\n    _proto.forEach = function forEach(callback, thisArg) {\n      for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {\n        var _step$value = _step.value, key = _step$value[0], value = _step$value[1];\n        callback.call(thisArg, value, key, this);\n      }\n    };\n    _proto.merge = function merge(other) {\n      var _this5 = this;\n      if (isObservableMap(other)) {\n        other = new Map(other);\n      }\n      transaction(function () {\n        if (isPlainObject(other)) {\n          getPlainObjectKeys(other).forEach(function (key) {\n            return _this5.set(key, other[key]);\n          });\n        } else if (Array.isArray(other)) {\n          other.forEach(function (_ref) {\n            var key = _ref[0], value = _ref[1];\n            return _this5.set(key, value);\n          });\n        } else if (isES6Map(other)) {\n          if (!isPlainES6Map(other)) {\n            die(19, other);\n          }\n          other.forEach(function (value, key) {\n            return _this5.set(key, value);\n          });\n        } else if (other !== null && other !== undefined) {\n          die(20, other);\n        }\n      });\n      return this;\n    };\n    _proto.clear = function clear() {\n      var _this6 = this;\n      transaction(function () {\n        untracked(function () {\n          for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {\n            var key = _step2.value;\n            _this6[\"delete\"](key);\n          }\n        });\n      });\n    };\n    _proto.replace = function replace(values) {\n      var _this7 = this;\n      transaction(function () {\n        var replacementMap = convertToMap(values);\n        var orderedData = new Map();\n        var keysReportChangedCalled = false;\n        for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {\n          var key = _step3.value;\n          if (!replacementMap.has(key)) {\n            var deleted = _this7[\"delete\"](key);\n            if (deleted) {\n              keysReportChangedCalled = true;\n            } else {\n              var value = _this7.data_.get(key);\n              orderedData.set(key, value);\n            }\n          }\n        }\n        for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {\n          var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];\n          var keyExisted = _this7.data_.has(_key);\n          _this7.set(_key, _value);\n          if (_this7.data_.has(_key)) {\n            var _value2 = _this7.data_.get(_key);\n            orderedData.set(_key, _value2);\n            if (!keyExisted) {\n              keysReportChangedCalled = true;\n            }\n          }\n        }\n        if (!keysReportChangedCalled) {\n          if (_this7.data_.size !== orderedData.size) {\n            _this7.keysAtom_.reportChanged();\n          } else {\n            var iter1 = _this7.data_.keys();\n            var iter2 = orderedData.keys();\n            var next1 = iter1.next();\n            var next2 = iter2.next();\n            while (!next1.done) {\n              if (next1.value !== next2.value) {\n                _this7.keysAtom_.reportChanged();\n                break;\n              }\n              next1 = iter1.next();\n              next2 = iter2.next();\n            }\n          }\n        }\n        _this7.data_ = orderedData;\n      });\n      return this;\n    };\n    _proto.toString = function toString() {\n      return \"[object ObservableMap]\";\n    };\n    _proto.toJSON = function toJSON() {\n      return Array.from(this);\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n      return registerListener(this, listener);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n      return registerInterceptor(this, handler);\n    };\n    return _createClass(ObservableMap, [{\n      key: \"size\",\n      get: function get() {\n        this.keysAtom_.reportObserved();\n        return this.data_.size;\n      }\n    }, {\n      key: Symbol.toStringTag,\n      get: function get() {\n        return \"Map\";\n      }\n    }]);\n  })();\n  var isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\n  function makeIterableForMap(iterator) {\n    iterator[Symbol.toStringTag] = \"MapIterator\";\n    return makeIterable(iterator);\n  }\n  function convertToMap(dataStructure) {\n    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {\n      return dataStructure;\n    } else if (Array.isArray(dataStructure)) {\n      return new Map(dataStructure);\n    } else if (isPlainObject(dataStructure)) {\n      var map = new Map();\n      for (var key in dataStructure) {\n        map.set(key, dataStructure[key]);\n      }\n      return map;\n    } else {\n      return die(21, dataStructure);\n    }\n  }\n  var ObservableSetMarker = {};\n  var ObservableSet = (function () {\n    function ObservableSet(initialData, enhancer, name_) {\n      var _this = this;\n      if (enhancer === void 0) {\n        enhancer = deepEnhancer;\n      }\n      if (name_ === void 0) {\n        name_ = \"ObservableSet\";\n      }\n      this.name_ = void 0;\n      this[$mobx] = ObservableSetMarker;\n      this.data_ = new Set();\n      this.atom_ = void 0;\n      this.changeListeners_ = void 0;\n      this.interceptors_ = void 0;\n      this.dehancer = void 0;\n      this.enhancer_ = void 0;\n      this.name_ = name_;\n      if (!isFunction(Set)) {\n        die(22);\n      }\n      this.enhancer_ = function (newV, oldV) {\n        return enhancer(newV, oldV, name_);\n      };\n      initObservable(function () {\n        _this.atom_ = createAtom(_this.name_);\n        if (initialData) {\n          _this.replace(initialData);\n        }\n      });\n    }\n    var _proto = ObservableSet.prototype;\n    _proto.dehanceValue_ = function dehanceValue_(value) {\n      if (this.dehancer !== undefined) {\n        return this.dehancer(value);\n      }\n      return value;\n    };\n    _proto.clear = function clear() {\n      var _this2 = this;\n      transaction(function () {\n        untracked(function () {\n          for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done; ) {\n            var value = _step.value;\n            _this2[\"delete\"](value);\n          }\n        });\n      });\n    };\n    _proto.forEach = function forEach(callbackFn, thisArg) {\n      for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {\n        var value = _step2.value;\n        callbackFn.call(thisArg, value, value, this);\n      }\n    };\n    _proto.add = function add(value) {\n      var _this3 = this;\n      checkIfStateModificationsAreAllowed(this.atom_);\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          type: ADD,\n          object: this,\n          newValue: value\n        });\n        if (!change) {\n          return this;\n        }\n      }\n      if (!this.has(value)) {\n        transaction(function () {\n          _this3.data_.add(_this3.enhancer_(value, undefined));\n          _this3.atom_.reportChanged();\n        });\n        var notifySpy = \"production\" !== \"production\";\n        var notify = hasListeners(this);\n        var _change = notify || notifySpy ? {\n          observableKind: \"set\",\n          debugObjectName: this.name_,\n          type: ADD,\n          object: this,\n          newValue: value\n        } : null;\n        if (notify) {\n          notifyListeners(this, _change);\n        }\n      }\n      return this;\n    };\n    _proto[\"delete\"] = function _delete(value) {\n      var _this4 = this;\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          type: DELETE,\n          object: this,\n          oldValue: value\n        });\n        if (!change) {\n          return false;\n        }\n      }\n      if (this.has(value)) {\n        var notifySpy = \"production\" !== \"production\";\n        var notify = hasListeners(this);\n        var _change2 = notify || notifySpy ? {\n          observableKind: \"set\",\n          debugObjectName: this.name_,\n          type: DELETE,\n          object: this,\n          oldValue: value\n        } : null;\n        transaction(function () {\n          _this4.atom_.reportChanged();\n          _this4.data_[\"delete\"](value);\n        });\n        if (notify) {\n          notifyListeners(this, _change2);\n        }\n        return true;\n      }\n      return false;\n    };\n    _proto.has = function has(value) {\n      this.atom_.reportObserved();\n      return this.data_.has(this.dehanceValue_(value));\n    };\n    _proto.entries = function entries() {\n      var nextIndex = 0;\n      var keys = Array.from(this.keys());\n      var values = Array.from(this.values());\n      return makeIterableForSet({\n        next: function next() {\n          var index = nextIndex;\n          nextIndex += 1;\n          return index < values.length ? {\n            value: [keys[index], values[index]],\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          };\n        }\n      });\n    };\n    _proto.keys = function keys() {\n      return this.values();\n    };\n    _proto.values = function values() {\n      this.atom_.reportObserved();\n      var self = this;\n      var nextIndex = 0;\n      var observableValues = Array.from(this.data_.values());\n      return makeIterableForSet({\n        next: function next() {\n          return nextIndex < observableValues.length ? {\n            value: self.dehanceValue_(observableValues[nextIndex++]),\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          };\n        }\n      });\n    };\n    _proto.intersection = function intersection(otherSet) {\n      if (isES6Set(otherSet) && !isObservableSet(otherSet)) {\n        return otherSet.intersection(this);\n      } else {\n        var dehancedSet = new Set(this);\n        return dehancedSet.intersection(otherSet);\n      }\n    };\n    _proto.union = function union(otherSet) {\n      if (isES6Set(otherSet) && !isObservableSet(otherSet)) {\n        return otherSet.union(this);\n      } else {\n        var dehancedSet = new Set(this);\n        return dehancedSet.union(otherSet);\n      }\n    };\n    _proto.difference = function difference(otherSet) {\n      return new Set(this).difference(otherSet);\n    };\n    _proto.symmetricDifference = function symmetricDifference(otherSet) {\n      if (isES6Set(otherSet) && !isObservableSet(otherSet)) {\n        return otherSet.symmetricDifference(this);\n      } else {\n        var dehancedSet = new Set(this);\n        return dehancedSet.symmetricDifference(otherSet);\n      }\n    };\n    _proto.isSubsetOf = function isSubsetOf(otherSet) {\n      return new Set(this).isSubsetOf(otherSet);\n    };\n    _proto.isSupersetOf = function isSupersetOf(otherSet) {\n      return new Set(this).isSupersetOf(otherSet);\n    };\n    _proto.isDisjointFrom = function isDisjointFrom(otherSet) {\n      if (isES6Set(otherSet) && !isObservableSet(otherSet)) {\n        return otherSet.isDisjointFrom(this);\n      } else {\n        var dehancedSet = new Set(this);\n        return dehancedSet.isDisjointFrom(otherSet);\n      }\n    };\n    _proto.replace = function replace(other) {\n      var _this5 = this;\n      if (isObservableSet(other)) {\n        other = new Set(other);\n      }\n      transaction(function () {\n        if (Array.isArray(other)) {\n          _this5.clear();\n          other.forEach(function (value) {\n            return _this5.add(value);\n          });\n        } else if (isES6Set(other)) {\n          _this5.clear();\n          other.forEach(function (value) {\n            return _this5.add(value);\n          });\n        } else if (other !== null && other !== undefined) {\n          die(\"Cannot initialize set from \" + other);\n        }\n      });\n      return this;\n    };\n    _proto.observe_ = function observe_(listener, fireImmediately) {\n      return registerListener(this, listener);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n      return registerInterceptor(this, handler);\n    };\n    _proto.toJSON = function toJSON() {\n      return Array.from(this);\n    };\n    _proto.toString = function toString() {\n      return \"[object ObservableSet]\";\n    };\n    _proto[Symbol.iterator] = function () {\n      return this.values();\n    };\n    return _createClass(ObservableSet, [{\n      key: \"size\",\n      get: function get() {\n        this.atom_.reportObserved();\n        return this.data_.size;\n      }\n    }, {\n      key: Symbol.toStringTag,\n      get: function get() {\n        return \"Set\";\n      }\n    }]);\n  })();\n  var isObservableSet = createInstanceofPredicate(\"ObservableSet\", ObservableSet);\n  function makeIterableForSet(iterator) {\n    iterator[Symbol.toStringTag] = \"SetIterator\";\n    return makeIterable(iterator);\n  }\n  var descriptorCache = Object.create(null);\n  var REMOVE = \"remove\";\n  var ObservableObjectAdministration = (function () {\n    function ObservableObjectAdministration(target_, values_, name_, defaultAnnotation_) {\n      if (values_ === void 0) {\n        values_ = new Map();\n      }\n      if (defaultAnnotation_ === void 0) {\n        defaultAnnotation_ = autoAnnotation;\n      }\n      this.target_ = void 0;\n      this.values_ = void 0;\n      this.name_ = void 0;\n      this.defaultAnnotation_ = void 0;\n      this.keysAtom_ = void 0;\n      this.changeListeners_ = void 0;\n      this.interceptors_ = void 0;\n      this.proxy_ = void 0;\n      this.isPlainObject_ = void 0;\n      this.appliedAnnotations_ = void 0;\n      this.pendingKeys_ = void 0;\n      this.target_ = target_;\n      this.values_ = values_;\n      this.name_ = name_;\n      this.defaultAnnotation_ = defaultAnnotation_;\n      this.keysAtom_ = new Atom(\"ObservableObject.keys\");\n      this.isPlainObject_ = isPlainObject(this.target_);\n    }\n    var _proto = ObservableObjectAdministration.prototype;\n    _proto.getObservablePropValue_ = function getObservablePropValue_(key) {\n      return this.values_.get(key).get();\n    };\n    _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {\n      var observable = this.values_.get(key);\n      if (observable instanceof ComputedValue) {\n        observable.set(newValue);\n        return true;\n      }\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          type: UPDATE,\n          object: this.proxy_ || this.target_,\n          name: key,\n          newValue: newValue\n        });\n        if (!change) {\n          return null;\n        }\n        newValue = change.newValue;\n      }\n      newValue = observable.prepareNewValue_(newValue);\n      if (newValue !== globalState.UNCHANGED) {\n        var notify = hasListeners(this);\n        var notifySpy = \"production\" !== \"production\";\n        var _change = notify || notifySpy ? {\n          type: UPDATE,\n          observableKind: \"object\",\n          debugObjectName: this.name_,\n          object: this.proxy_ || this.target_,\n          oldValue: observable.value_,\n          name: key,\n          newValue: newValue\n        } : null;\n        observable.setNewValue_(newValue);\n        if (notify) {\n          notifyListeners(this, _change);\n        }\n      }\n      return true;\n    };\n    _proto.get_ = function get_(key) {\n      if (globalState.trackingDerivation && !hasProp(this.target_, key)) {\n        this.has_(key);\n      }\n      return this.target_[key];\n    };\n    _proto.set_ = function set_(key, value, proxyTrap) {\n      if (proxyTrap === void 0) {\n        proxyTrap = false;\n      }\n      if (hasProp(this.target_, key)) {\n        if (this.values_.has(key)) {\n          return this.setObservablePropValue_(key, value);\n        } else if (proxyTrap) {\n          return Reflect.set(this.target_, key, value);\n        } else {\n          this.target_[key] = value;\n          return true;\n        }\n      } else {\n        return this.extend_(key, {\n          value: value,\n          enumerable: true,\n          writable: true,\n          configurable: true\n        }, this.defaultAnnotation_, proxyTrap);\n      }\n    };\n    _proto.has_ = function has_(key) {\n      if (!globalState.trackingDerivation) {\n        return (key in this.target_);\n      }\n      this.pendingKeys_ || (this.pendingKeys_ = new Map());\n      var entry = this.pendingKeys_.get(key);\n      if (!entry) {\n        entry = new ObservableValue((key in this.target_), referenceEnhancer, \"ObservableObject.key?\", false);\n        this.pendingKeys_.set(key, entry);\n      }\n      return entry.get();\n    };\n    _proto.make_ = function make_(key, annotation) {\n      if (annotation === true) {\n        annotation = this.defaultAnnotation_;\n      }\n      if (annotation === false) {\n        return;\n      }\n      if (!((key in this.target_))) {\n        var _this$target_$storedA;\n        if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {\n          return;\n        } else {\n          die(1, annotation.annotationType_, this.name_ + \".\" + key.toString());\n        }\n      }\n      var source = this.target_;\n      while (source && source !== objectPrototype) {\n        var descriptor = getDescriptor(source, key);\n        if (descriptor) {\n          var outcome = annotation.make_(this, key, descriptor, source);\n          if (outcome === 0) {\n            return;\n          }\n          if (outcome === 1) {\n            break;\n          }\n        }\n        source = Object.getPrototypeOf(source);\n      }\n      recordAnnotationApplied(this, annotation, key);\n    };\n    _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {\n      if (proxyTrap === void 0) {\n        proxyTrap = false;\n      }\n      if (annotation === true) {\n        annotation = this.defaultAnnotation_;\n      }\n      if (annotation === false) {\n        return this.defineProperty_(key, descriptor, proxyTrap);\n      }\n      var outcome = annotation.extend_(this, key, descriptor, proxyTrap);\n      if (outcome) {\n        recordAnnotationApplied(this, annotation, key);\n      }\n      return outcome;\n    };\n    _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {\n      if (proxyTrap === void 0) {\n        proxyTrap = false;\n      }\n      checkIfStateModificationsAreAllowed(this.keysAtom_);\n      try {\n        startBatch();\n        var deleteOutcome = this.delete_(key);\n        if (!deleteOutcome) {\n          return deleteOutcome;\n        }\n        if (hasInterceptors(this)) {\n          var change = interceptChange(this, {\n            object: this.proxy_ || this.target_,\n            name: key,\n            type: ADD,\n            newValue: descriptor.value\n          });\n          if (!change) {\n            return null;\n          }\n          var newValue = change.newValue;\n          if (descriptor.value !== newValue) {\n            descriptor = _extends({}, descriptor, {\n              value: newValue\n            });\n          }\n        }\n        if (proxyTrap) {\n          if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n            return false;\n          }\n        } else {\n          defineProperty(this.target_, key, descriptor);\n        }\n        this.notifyPropertyAddition_(key, descriptor.value);\n      } finally {\n        endBatch();\n      }\n      return true;\n    };\n    _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {\n      if (proxyTrap === void 0) {\n        proxyTrap = false;\n      }\n      checkIfStateModificationsAreAllowed(this.keysAtom_);\n      try {\n        startBatch();\n        var deleteOutcome = this.delete_(key);\n        if (!deleteOutcome) {\n          return deleteOutcome;\n        }\n        if (hasInterceptors(this)) {\n          var change = interceptChange(this, {\n            object: this.proxy_ || this.target_,\n            name: key,\n            type: ADD,\n            newValue: value\n          });\n          if (!change) {\n            return null;\n          }\n          value = change.newValue;\n        }\n        var cachedDescriptor = getCachedObservablePropDescriptor(key);\n        var descriptor = {\n          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n          enumerable: true,\n          get: cachedDescriptor.get,\n          set: cachedDescriptor.set\n        };\n        if (proxyTrap) {\n          if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n            return false;\n          }\n        } else {\n          defineProperty(this.target_, key, descriptor);\n        }\n        var observable = new ObservableValue(value, enhancer, \"production\" !== \"production\" ? this.name_ + \".\" + key.toString() : \"ObservableObject.key\", false);\n        this.values_.set(key, observable);\n        this.notifyPropertyAddition_(key, observable.value_);\n      } finally {\n        endBatch();\n      }\n      return true;\n    };\n    _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {\n      if (proxyTrap === void 0) {\n        proxyTrap = false;\n      }\n      checkIfStateModificationsAreAllowed(this.keysAtom_);\n      try {\n        startBatch();\n        var deleteOutcome = this.delete_(key);\n        if (!deleteOutcome) {\n          return deleteOutcome;\n        }\n        if (hasInterceptors(this)) {\n          var change = interceptChange(this, {\n            object: this.proxy_ || this.target_,\n            name: key,\n            type: ADD,\n            newValue: undefined\n          });\n          if (!change) {\n            return null;\n          }\n        }\n        options.name || (options.name = \"production\" !== \"production\" ? this.name_ + \".\" + key.toString() : \"ObservableObject.key\");\n        options.context = this.proxy_ || this.target_;\n        var cachedDescriptor = getCachedObservablePropDescriptor(key);\n        var descriptor = {\n          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,\n          enumerable: false,\n          get: cachedDescriptor.get,\n          set: cachedDescriptor.set\n        };\n        if (proxyTrap) {\n          if (!Reflect.defineProperty(this.target_, key, descriptor)) {\n            return false;\n          }\n        } else {\n          defineProperty(this.target_, key, descriptor);\n        }\n        this.values_.set(key, new ComputedValue(options));\n        this.notifyPropertyAddition_(key, undefined);\n      } finally {\n        endBatch();\n      }\n      return true;\n    };\n    _proto.delete_ = function delete_(key, proxyTrap) {\n      if (proxyTrap === void 0) {\n        proxyTrap = false;\n      }\n      checkIfStateModificationsAreAllowed(this.keysAtom_);\n      if (!hasProp(this.target_, key)) {\n        return true;\n      }\n      if (hasInterceptors(this)) {\n        var change = interceptChange(this, {\n          object: this.proxy_ || this.target_,\n          name: key,\n          type: REMOVE\n        });\n        if (!change) {\n          return null;\n        }\n      }\n      try {\n        var _this$pendingKeys_;\n        startBatch();\n        var notify = hasListeners(this);\n        var notifySpy = \"production\" !== \"production\" && isSpyEnabled();\n        var observable = this.values_.get(key);\n        var value = undefined;\n        if (!observable && (notify || notifySpy)) {\n          var _getDescriptor;\n          value = (_getDescriptor = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor.value;\n        }\n        if (proxyTrap) {\n          if (!Reflect.deleteProperty(this.target_, key)) {\n            return false;\n          }\n        } else {\n          delete this.target_[key];\n        }\n        if (\"production\" !== \"production\") ;\n        if (observable) {\n          this.values_[\"delete\"](key);\n          if (observable instanceof ObservableValue) {\n            value = observable.value_;\n          }\n          propagateChanged(observable);\n        }\n        this.keysAtom_.reportChanged();\n        (_this$pendingKeys_ = this.pendingKeys_) == null || (_this$pendingKeys_ = _this$pendingKeys_.get(key)) == null || _this$pendingKeys_.set((key in this.target_));\n        if (notify || notifySpy) {\n          var _change2 = {\n            type: REMOVE,\n            observableKind: \"object\",\n            object: this.proxy_ || this.target_,\n            debugObjectName: this.name_,\n            oldValue: value,\n            name: key\n          };\n          if (\"production\" !== \"production\" && notifySpy) ;\n          if (notify) {\n            notifyListeners(this, _change2);\n          }\n          if (\"production\" !== \"production\" && notifySpy) ;\n        }\n      } finally {\n        endBatch();\n      }\n      return true;\n    };\n    _proto.observe_ = function observe_(callback, fireImmediately) {\n      return registerListener(this, callback);\n    };\n    _proto.intercept_ = function intercept_(handler) {\n      return registerInterceptor(this, handler);\n    };\n    _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {\n      var _this$pendingKeys_2;\n      var notify = hasListeners(this);\n      var notifySpy = \"production\" !== \"production\";\n      if (notify || notifySpy) {\n        var change = notify || notifySpy ? {\n          type: ADD,\n          observableKind: \"object\",\n          debugObjectName: this.name_,\n          object: this.proxy_ || this.target_,\n          name: key,\n          newValue: value\n        } : null;\n        if (notify) {\n          notifyListeners(this, change);\n        }\n      }\n      (_this$pendingKeys_2 = this.pendingKeys_) == null || (_this$pendingKeys_2 = _this$pendingKeys_2.get(key)) == null || _this$pendingKeys_2.set(true);\n      this.keysAtom_.reportChanged();\n    };\n    _proto.ownKeys_ = function ownKeys_() {\n      this.keysAtom_.reportObserved();\n      return ownKeys(this.target_);\n    };\n    _proto.keys_ = function keys_() {\n      this.keysAtom_.reportObserved();\n      return Object.keys(this.target_);\n    };\n    return ObservableObjectAdministration;\n  })();\n  function asObservableObject(target, options) {\n    var _options$name;\n    if (hasProp(target, $mobx)) {\n      return target;\n    }\n    var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : \"ObservableObject\";\n    var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));\n    addHiddenProp(target, $mobx, adm);\n    return target;\n  }\n  var isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\n  function getCachedObservablePropDescriptor(key) {\n    return descriptorCache[key] || (descriptorCache[key] = {\n      get: function get() {\n        return this[$mobx].getObservablePropValue_(key);\n      },\n      set: function set(value) {\n        return this[$mobx].setObservablePropValue_(key, value);\n      }\n    });\n  }\n  function isObservableObject(thing) {\n    if (isObject(thing)) {\n      return isObservableObjectAdministration(thing[$mobx]);\n    }\n    return false;\n  }\n  function recordAnnotationApplied(adm, annotation, key) {\n    var _adm$target_$storedAn;\n    (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null || delete _adm$target_$storedAn[key];\n  }\n  var ENTRY_0 = createArrayEntryDescriptor(0);\n  var safariPrototypeSetterInheritanceBug = (function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", {\n      set: function set() {\n        v = true;\n      }\n    });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n  })();\n  var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\n  var StubArray = function StubArray() {};\n  function inherit(ctor, proto) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(ctor.prototype, proto);\n    } else if (ctor.prototype.__proto__ !== undefined) {\n      ctor.prototype.__proto__ = proto;\n    } else {\n      ctor.prototype = proto;\n    }\n  }\n  inherit(StubArray, Array.prototype);\n  var LegacyObservableArray = (function (_StubArray) {\n    function LegacyObservableArray(initialValues, enhancer, name, owned) {\n      var _this;\n      if (name === void 0) {\n        name = \"ObservableArray\";\n      }\n      if (owned === void 0) {\n        owned = false;\n      }\n      _this = _StubArray.call(this) || this;\n      initObservable(function () {\n        var adm = new ObservableArrayAdministration(name, enhancer, owned, true);\n        adm.proxy_ = _this;\n        addHiddenFinalProp(_this, $mobx, adm);\n        if (initialValues && initialValues.length) {\n          _this.spliceWithArray(0, 0, initialValues);\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n          Object.defineProperty(_this, \"0\", ENTRY_0);\n        }\n      });\n      return _this;\n    }\n    _inheritsLoose(LegacyObservableArray, _StubArray);\n    var _proto = LegacyObservableArray.prototype;\n    _proto.concat = function concat() {\n      this[$mobx].atom_.reportObserved();\n      for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n        arrays[_key] = arguments[_key];\n      }\n      return Array.prototype.concat.apply(this.slice(), arrays.map(function (a) {\n        return isObservableArray(a) ? a.slice() : a;\n      }));\n    };\n    _proto[Symbol.iterator] = function () {\n      var self = this;\n      var nextIndex = 0;\n      return makeIterable({\n        next: function next() {\n          return nextIndex < self.length ? {\n            value: self[nextIndex++],\n            done: false\n          } : {\n            done: true,\n            value: undefined\n          };\n        }\n      });\n    };\n    return _createClass(LegacyObservableArray, [{\n      key: \"length\",\n      get: function get() {\n        return this[$mobx].getArrayLength_();\n      },\n      set: function set(newLength) {\n        this[$mobx].setArrayLength_(newLength);\n      }\n    }, {\n      key: Symbol.toStringTag,\n      get: function get() {\n        return \"Array\";\n      }\n    }]);\n  })(StubArray);\n  Object.entries(arrayExtensions).forEach(function (_ref) {\n    var prop = _ref[0], fn = _ref[1];\n    if (prop !== \"concat\") {\n      addHiddenProp(LegacyObservableArray.prototype, prop, fn);\n    }\n  });\n  function createArrayEntryDescriptor(index) {\n    return {\n      enumerable: false,\n      configurable: true,\n      get: function get() {\n        return this[$mobx].get_(index);\n      },\n      set: function set(value) {\n        this[$mobx].set_(index, value);\n      }\n    };\n  }\n  function createArrayBufferItem(index) {\n    defineProperty(LegacyObservableArray.prototype, \"\" + index, createArrayEntryDescriptor(index));\n  }\n  function reserveArrayBuffer(max) {\n    if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {\n      for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {\n        createArrayBufferItem(index);\n      }\n      OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n    }\n  }\n  reserveArrayBuffer(1000);\n  function createLegacyArray(initialValues, enhancer, name) {\n    return new LegacyObservableArray(initialValues, enhancer, name);\n  }\n  function getAtom(thing, property) {\n    if (typeof thing === \"object\" && thing !== null) {\n      if (isObservableArray(thing)) {\n        if (property !== undefined) {\n          die(23);\n        }\n        return thing[$mobx].atom_;\n      }\n      if (isObservableSet(thing)) {\n        return thing.atom_;\n      }\n      if (isObservableMap(thing)) {\n        if (property === undefined) {\n          return thing.keysAtom_;\n        }\n        var observable = thing.data_.get(property) || thing.hasMap_.get(property);\n        if (!observable) {\n          die(25, property, getDebugName(thing));\n        }\n        return observable;\n      }\n      if (isObservableObject(thing)) {\n        if (!property) {\n          return die(26);\n        }\n        var _observable = thing[$mobx].values_.get(property);\n        if (!_observable) {\n          die(27, property, getDebugName(thing));\n        }\n        return _observable;\n      }\n      if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n        return thing;\n      }\n    } else if (isFunction(thing)) {\n      if (isReaction(thing[$mobx])) {\n        return thing[$mobx];\n      }\n    }\n    die(28);\n  }\n  function getAdministration(thing, property) {\n    if (!thing) {\n      die(29);\n    }\n    if (property !== undefined) {\n      return getAdministration(getAtom(thing, property));\n    }\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n      return thing;\n    }\n    if (isObservableMap(thing) || isObservableSet(thing)) {\n      return thing;\n    }\n    if (thing[$mobx]) {\n      return thing[$mobx];\n    }\n    die(24, thing);\n  }\n  function getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) {\n      named = getAtom(thing, property);\n    } else if (isAction(thing)) {\n      return thing.name;\n    } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {\n      named = getAdministration(thing);\n    } else {\n      named = getAtom(thing);\n    }\n    return named.name_;\n  }\n  function initObservable(cb) {\n    var derivation = untrackedStart();\n    var allowStateChanges = allowStateChangesStart(true);\n    startBatch();\n    try {\n      return cb();\n    } finally {\n      endBatch();\n      allowStateChangesEnd(allowStateChanges);\n      untrackedEnd(derivation);\n    }\n  }\n  var toString = objectPrototype.toString;\n  function deepEqual(a, b, depth) {\n    if (depth === void 0) {\n      depth = -1;\n    }\n    return eq(a, b, depth);\n  }\n  function eq(a, b, depth, aStack, bStack) {\n    if (a === b) {\n      return a !== 0 || 1 / a === 1 / b;\n    }\n    if (a == null || b == null) {\n      return false;\n    }\n    if (a !== a) {\n      return b !== b;\n    }\n    var type = typeof a;\n    if (type !== \"function\" && type !== \"object\" && typeof b != \"object\") {\n      return false;\n    }\n    var className = toString.call(a);\n    if (className !== toString.call(b)) {\n      return false;\n    }\n    switch (className) {\n      case \"[object RegExp]\":\n      case \"[object String]\":\n        return \"\" + a === \"\" + b;\n      case \"[object Number]\":\n        if (+a !== +a) {\n          return +b !== +b;\n        }\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case \"[object Date]\":\n      case \"[object Boolean]\":\n        return +a === +b;\n      case \"[object Symbol]\":\n        return typeof Symbol !== \"undefined\" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);\n      case \"[object Map]\":\n      case \"[object Set]\":\n        if (depth >= 0) {\n          depth++;\n        }\n        break;\n    }\n    a = unwrap(a);\n    b = unwrap(b);\n    var areArrays = className === \"[object Array]\";\n    if (!areArrays) {\n      if (typeof a != \"object\" || typeof b != \"object\") {\n        return false;\n      }\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && (\"constructor\" in a) && (\"constructor\" in b)) {\n        return false;\n      }\n    }\n    if (depth === 0) {\n      return false;\n    } else if (depth < 0) {\n      depth = -1;\n    }\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      if (aStack[length] === a) {\n        return bStack[length] === b;\n      }\n    }\n    aStack.push(a);\n    bStack.push(b);\n    if (areArrays) {\n      length = a.length;\n      if (length !== b.length) {\n        return false;\n      }\n      while (length--) {\n        if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {\n          return false;\n        }\n      }\n    } else {\n      var keys = Object.keys(a);\n      var key;\n      length = keys.length;\n      if (Object.keys(b).length !== length) {\n        return false;\n      }\n      while (length--) {\n        key = keys[length];\n        if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {\n          return false;\n        }\n      }\n    }\n    aStack.pop();\n    bStack.pop();\n    return true;\n  }\n  function unwrap(a) {\n    if (isObservableArray(a)) {\n      return a.slice();\n    }\n    if (isES6Map(a) || isObservableMap(a)) {\n      return Array.from(a.entries());\n    }\n    if (isES6Set(a) || isObservableSet(a)) {\n      return Array.from(a.entries());\n    }\n    return a;\n  }\n  var _getGlobal$Iterator;\n  var maybeIteratorPrototype = ((_getGlobal$Iterator = getGlobal().Iterator) == null ? void 0 : _getGlobal$Iterator.prototype) || ({});\n  function makeIterable(iterator) {\n    iterator[Symbol.iterator] = getSelf;\n    return Object.assign(Object.create(maybeIteratorPrototype), iterator);\n  }\n  function getSelf() {\n    return this;\n  }\n  [\"Symbol\", \"Map\", \"Set\"].forEach(function (m) {\n    var g = getGlobal();\n    if (typeof g[m] === \"undefined\") {\n      die(\"MobX requires global '\" + m + \"' to be available or polyfilled\");\n    }\n  });\n  if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({\n      spy: spy,\n      extras: {\n        getDebugName: getDebugName\n      },\n      $mobx: $mobx\n    });\n  }\n\n  const __esModule = true;\n\n  exports.$mobx = $mobx;\n  exports.FlowCancellationError = FlowCancellationError;\n  exports.ObservableMap = ObservableMap;\n  exports.ObservableSet = ObservableSet;\n  exports.Reaction = Reaction;\n  exports.__esModule = __esModule;\n  exports._allowStateChanges = allowStateChanges;\n  exports._allowStateChangesInsideComputed = runInAction;\n  exports._allowStateReadsEnd = allowStateReadsEnd;\n  exports._allowStateReadsStart = allowStateReadsStart;\n  exports._autoAction = autoAction;\n  exports._endAction = _endAction;\n  exports._getAdministration = getAdministration;\n  exports._getGlobalState = getGlobalState;\n  exports._interceptReads = interceptReads;\n  exports._isComputingDerivation = isComputingDerivation;\n  exports._resetGlobalState = resetGlobalState;\n  exports._startAction = _startAction;\n  exports.action = action;\n  exports.autorun = autorun;\n  exports.comparer = comparer;\n  exports.computed = computed;\n  exports.configure = configure;\n  exports.createAtom = createAtom;\n  exports.defineProperty = apiDefineProperty;\n  exports.entries = entries;\n  exports.extendObservable = extendObservable;\n  exports.flow = flow;\n  exports.flowResult = flowResult;\n  exports.get = get;\n  exports.getAtom = getAtom;\n  exports.getDebugName = getDebugName;\n  exports.getDependencyTree = getDependencyTree;\n  exports.getObserverTree = getObserverTree;\n  exports.has = has;\n  exports.intercept = intercept;\n  exports.isAction = isAction;\n  exports.isBoxedObservable = isObservableValue;\n  exports.isComputed = isComputed;\n  exports.isComputedProp = isComputedProp;\n  exports.isFlow = isFlow;\n  exports.isFlowCancellationError = isFlowCancellationError;\n  exports.isObservable = isObservable;\n  exports.isObservableArray = isObservableArray;\n  exports.isObservableMap = isObservableMap;\n  exports.isObservableObject = isObservableObject;\n  exports.isObservableProp = isObservableProp;\n  exports.isObservableSet = isObservableSet;\n  exports.keys = keys;\n  exports.makeAutoObservable = makeAutoObservable;\n  exports.makeObservable = makeObservable;\n  exports.observable = observable;\n  exports.observe = observe;\n  exports.onBecomeObserved = onBecomeObserved;\n  exports.onBecomeUnobserved = onBecomeUnobserved;\n  exports.onReactionError = onReactionError;\n  exports.override = override;\n  exports.ownKeys = apiOwnKeys;\n  exports.reaction = reaction;\n  exports.remove = remove;\n  exports.runInAction = runInAction;\n  exports.set = set;\n  exports.spy = spy;\n  exports.toJS = toJS;\n  exports.trace = trace;\n  exports.transaction = transaction;\n  exports.untracked = untracked;\n  exports.values = values;\n  exports.when = when;\n\n}));\n"
    }
  ]
}